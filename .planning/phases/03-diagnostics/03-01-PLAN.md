---
phase: 03-diagnostics
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified: [js/diagnostics.js]
autonomous: true

must_haves:
  truths:
    - "detectOnsetDelays returns tiered severity (developing/flag/frustration) based on inter-word gaps"
    - "detectLongPauses finds 3s+ gaps with extra allowance at punctuation positions"
    - "detectSelfCorrections identifies repeated consecutive words and excludes reference-legitimate repeats"
    - "detectMorphologicalErrors flags substitutions sharing 3+ char prefix with confidence < 0.8"
    - "computeProsodyProxy returns ratio of avg pause at punctuation vs mid-sentence"
    - "runDiagnostics orchestrates all five and returns unified object"
  artifacts:
    - path: "js/diagnostics.js"
      provides: "All five diagnostic analyzers plus orchestrator"
      exports: ["detectOnsetDelays", "detectLongPauses", "detectSelfCorrections", "detectMorphologicalErrors", "computeProsodyProxy", "runDiagnostics"]
  key_links:
    - from: "js/diagnostics.js"
      to: "STT word objects"
      via: "parseTime helper parsing startTime/endTime strings"
      pattern: "parseFloat.*replace.*s"
---

<objective>
Create the diagnostics computation module with all five analyzers for fluency challenge detection.

Purpose: Provide the core diagnostic logic that detects onset delays, long pauses, self-corrections, morphological errors, and prosody patterns from STT timestamps and confidence scores.
Output: `js/diagnostics.js` with named exports for each analyzer plus `runDiagnostics` orchestrator.
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-diagnostics/03-RESEARCH.md
@js/alignment.js
@js/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create js/diagnostics.js with all five analyzers and orchestrator</name>
  <files>js/diagnostics.js</files>
  <action>
Create `js/diagnostics.js` with these named exports:

**Helper: `parseTime(t)`** — Parse STT time string "1.200s" to float. `parseFloat(String(t).replace('s', '')) || 0`.

**DIAG-01: `detectOnsetDelays(transcriptWords)`**
- For each word, compute gap = startTime[i] - endTime[i-1]. For first word, gap = startTime[0].
- First word: use higher threshold (skip if gap < 3s to avoid recording lead-in false positives). For all other words: severity = 'frustration' if gap >= 5, 'flag' if gap >= 3, 'developing' if gap >= 1.5, else null.
- Return array of `{ wordIndex, word, gap (rounded to 0.1), severity }` for non-null severity.

**DIAG-02: `detectLongPauses(transcriptWords, referenceText, alignment)`**
- Build punctuation positions map from referenceText: split on whitespace, check if each word ends with [.!?] (period) or [,;:] (comma). Map ref word index -> punctuation type.
- Build STT-to-ref index mapping: iterate alignment, track refIndex (increment for non-insertion types) and hypIndex (increment for non-omission types). Build map from hypIndex -> refIndex.
- For each consecutive pair of STT words, compute gap. Base threshold = 3s. If the preceding reference word (via mapping) has punctuation after it, add allowance: +1.5s for comma, +2s for period. Only flag gaps exceeding the adjusted threshold.
- Return array of `{ afterWordIndex, gap (rounded to 0.1), threshold, punctuationType (or null) }`.

**DIAG-03: `detectSelfCorrections(transcriptWords, alignment)`**
- Normalize STT words to lowercase. Look for consecutive repeated words (words[i] === words[i-1]).
- Cross-reference against alignment: if the reference text legitimately has the same word repeated at that position, skip (not a self-correction). Use alignment to check — if two consecutive correct matches both have the same ref word, that's legitimate.
- Also detect 2-word phrase repeats: words[i-2..i-1] === words[i..i+1].
- Return array of `{ type: 'word-repeat'|'phrase-repeat', startIndex, word(s), count }`.

**DIAG-04: `detectMorphologicalErrors(alignment, sttLookup)`**
- For each substitution in alignment where ref and hyp both exist:
  - Compute shared prefix length (char by char comparison of ref vs hyp, both lowercase).
  - If shared prefix >= 3 chars AND ref !== hyp:
    - Look up hyp in sttLookup. If confidence < 0.8, flag it.
- Return array of `{ ref, hyp, sharedPrefix, confidence }`.

**DIAG-05: `computeProsodyProxy(transcriptWords, referenceText, alignment)`**
- Build punctuation positions map (same as DIAG-02, factor out into shared helper `getPunctuationPositions(referenceText)`).
- Build STT-to-ref mapping (same as DIAG-02, factor out into shared helper `buildHypToRefMap(alignment)`).
- For each inter-word gap, classify: if preceding ref word has punctuation -> "at-punctuation" pause, else -> "mid-sentence" pause.
- Compute avgPauseAtPunct and avgPauseMid. Ratio = avgPauseAtPunct / avgPauseMid (guard against division by zero with 0.001 floor).
- Return `{ ratio (rounded to 0.1), avgPauseAtPunct (rounded to 0.01), avgPauseMid (rounded to 0.01), punctuationPauses (count), midSentencePauses (count) }`.

**Orchestrator: `runDiagnostics(transcriptWords, alignment, referenceText, sttLookup)`**
- Call all five analyzers, return `{ onsetDelays, longPauses, selfCorrections, morphologicalErrors, prosodyProxy }`.

Factor out shared helpers: `parseTime`, `getPunctuationPositions(referenceText)`, `buildHypToRefMap(alignment)`.

Do NOT modify any existing files in this task.
  </action>
  <verify>
Open js/diagnostics.js in browser dev console:
- Import and call `detectOnsetDelays([{word:'the', startTime:'0s', endTime:'0.5s'}, {word:'cat', startTime:'3.5s', endTime:'4s'}])` — should return one entry with severity 'flag', gap 3.
- Verify all six functions are exported.
- No syntax errors (load index.html, check console for import errors after Plan 02 wires it).
  </verify>
  <done>
js/diagnostics.js exports all six functions. detectOnsetDelays correctly tiers gaps. detectLongPauses applies punctuation allowance. detectSelfCorrections finds repeats and filters reference-legitimate ones. detectMorphologicalErrors checks shared prefix + low confidence. computeProsodyProxy returns pause ratio. runDiagnostics returns unified object.
  </done>
</task>

</tasks>

<verification>
- js/diagnostics.js exists and exports: detectOnsetDelays, detectLongPauses, detectSelfCorrections, detectMorphologicalErrors, computeProsodyProxy, runDiagnostics
- Each function handles empty input arrays gracefully (returns empty array or neutral object)
- parseTime handles "0s", "1.200s", undefined, null without crashing
</verification>

<success_criteria>
All five diagnostic analyzers implemented with correct thresholds and a runDiagnostics orchestrator that calls all five. Module is self-contained with no modifications to existing files.
</success_criteria>

<output>
After completion, create `.planning/phases/03-diagnostics/03-01-SUMMARY.md`
</output>
