---
phase: 13-confidence-classification
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - js/confidence-classifier.js
autonomous: true

must_haves:
  truths:
    - "Words with source='both' use default model confidence as-is"
    - "latest_only words IN reference get confidence 0.85 (valid mumble)"
    - "latest_only words NOT in reference get confidence 0.50 and 'possible_insertion' flag"
    - "default_only words IN reference get default's confidence but trustLevel capped at medium"
    - "default_only words NOT in reference get trustLevel 'low'"
    - "VAD ghost words get confidence 0.0 and trustLevel 'ghost'"
  artifacts:
    - path: "js/confidence-classifier.js"
      provides: "Asymmetric trust policy implementation"
      exports: ["classifyWordConfidence", "classifyAllWords", "buildReferenceSet"]
  key_links:
    - from: "js/confidence-classifier.js"
      to: "js/confidence-config.js"
      via: "import thresholds"
      pattern: "import.*CONFIDENCE_THRESHOLDS"
    - from: "js/confidence-classifier.js"
      to: "js/word-equivalences.js"
      via: "import getAllEquivalents"
      pattern: "import.*getAllEquivalents"
---

<objective>
Create confidence classifier module that applies asymmetric trust policy based on model agreement and reference presence.

Purpose: Classify word confidence BEFORE alignment so hallucinations don't warp WCPM scores. The 0.85 "valid mumble" confidence is high enough to count but acknowledges uncertainty. The 0.50 "hallucination risk" is deliberately below the Medium threshold (0.70).
Output: js/confidence-classifier.js with classifyWordConfidence(), classifyAllWords(), buildReferenceSet()
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-confidence-classification/13-CONTEXT.md
@.planning/phases/13-confidence-classification/13-RESEARCH.md
@.planning/phases/13-confidence-classification/13-01-SUMMARY.md

@js/confidence-config.js
@js/word-equivalences.js
@js/ensemble-merger.js
@js/ghost-detector.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create buildReferenceSet function</name>
  <files>js/confidence-classifier.js</files>
  <action>
Create new file js/confidence-classifier.js with reference set builder:

```javascript
/**
 * Confidence classifier with asymmetric trust policy.
 * Classifies words based on model agreement (_source) and reference presence.
 *
 * Pipeline order: Classify -> Filter ghosts -> Align
 */

import { CONFIDENCE_THRESHOLDS, TRUST_LEVELS, CONFIDENCE_FLAGS } from './confidence-config.js';
import { getCanonical, getAllEquivalents } from './word-equivalences.js';

/**
 * Normalize word for reference matching.
 * Per CONTEXT.md: case-insensitive, strip punctuation except apostrophes/hyphens.
 * @param {string} word
 * @returns {string}
 */
function normalizeWord(word) {
  if (!word) return '';
  return word.toLowerCase().replace(/^[^a-z0-9'-]+|[^a-z0-9'-]+$/g, '');
}

/**
 * Build a Set of all canonical word forms from reference text.
 * Expands ALL reference words to ALL equivalent forms for O(1) lookup.
 *
 * Per CONTEXT.md reference matching rules:
 * - Case-insensitive
 * - Strip punctuation except apostrophes/hyphens
 * - Homophones match
 * - Numbers match word forms
 * - Hyphenated compounds match multiple forms (well-known = wellknown = well known)
 *
 * @param {string} referenceText
 * @returns {Set<string>} Set of all acceptable word forms
 */
export function buildReferenceSet(referenceText) {
  if (!referenceText || typeof referenceText !== 'string') {
    return new Set();
  }

  const words = referenceText.split(/\s+/).filter(Boolean);
  const refSet = new Set();

  for (const word of words) {
    const normalized = normalizeWord(word);
    if (!normalized) continue;

    // Add the word itself
    refSet.add(normalized);

    // Add canonical form
    const canonical = getCanonical(normalized);
    refSet.add(canonical);

    // Add ALL equivalents (homophones, numbers, etc.)
    const equivalents = getAllEquivalents(normalized);
    for (const eq of equivalents) {
      refSet.add(eq);
    }

    // Handle hyphenated compounds: "well-known" matches "wellknown" and "well known"
    if (normalized.includes('-')) {
      // Without hyphens (wellknown)
      refSet.add(normalized.replace(/-/g, ''));
      // As separate words - add each part
      const parts = normalized.split('-');
      for (const part of parts) {
        refSet.add(part);
      }
    }
  }

  return refSet;
}
```

This establishes the foundation for reference matching with full equivalence expansion.
  </action>
  <verify>
Browser console test:
```javascript
import { buildReferenceSet } from './js/confidence-classifier.js';
const ref = buildReferenceSet("The cat went there. She said twenty-one.");
console.assert(ref.has('the'), 'Has the');
console.assert(ref.has('their'), 'Has their (homophone of there)');
console.assert(ref.has('21'), 'Has 21 (number form)');
console.assert(ref.has('twentyone'), 'Has twentyone (no hyphen)');
console.log('buildReferenceSet tests passed');
```
  </verify>
  <done>
- buildReferenceSet() created and exported
- Normalizes case and punctuation
- Expands homophones via getAllEquivalents()
- Handles hyphenated compounds
- Returns Set for O(1) lookup
  </done>
</task>

<task type="auto">
  <name>Task 2: Create classifyWordConfidence function</name>
  <files>js/confidence-classifier.js</files>
  <action>
Add to js/confidence-classifier.js after buildReferenceSet:

```javascript
/**
 * Determine trust level from confidence score.
 * Per CONTEXT.md: thresholds are INCLUSIVE.
 * @param {number} confidence
 * @returns {string} Trust level: 'high' | 'medium' | 'low' | 'ghost'
 */
function getTrustLevel(confidence) {
  if (confidence === 0) return TRUST_LEVELS.GHOST;
  if (confidence >= CONFIDENCE_THRESHOLDS.HIGH) return TRUST_LEVELS.HIGH;
  if (confidence >= CONFIDENCE_THRESHOLDS.MEDIUM) return TRUST_LEVELS.MEDIUM;
  return TRUST_LEVELS.LOW;
}

/**
 * Classify a single word's confidence using asymmetric trust policy.
 *
 * Per CONTEXT.md trust policy:
 * - Both models: use default model's confidence as-is
 * - latest_only + IN ref: 0.85 (valid mumble - student likely mumbled correctly)
 * - latest_only + NOT in ref: 0.50 + possible_insertion flag (hallucination risk)
 * - default_only + IN ref: use default's confidence, CAP trustLevel at MEDIUM
 * - default_only + NOT in ref: LOW trust (phantom from weaker model)
 *
 * VAD ghost flag overrides everything to confidence 0.0.
 *
 * @param {object} word - Merged word with source and _debug
 * @param {Set<string>} referenceSet - Set from buildReferenceSet()
 * @returns {object} { confidence, trustLevel, _flags }
 */
export function classifyWordConfidence(word, referenceSet) {
  const flags = [];

  // Check VAD ghost flag first (highest priority override)
  if (word.vad_ghost_in_reference) {
    flags.push(CONFIDENCE_FLAGS.VAD_GHOST);
    return {
      confidence: 0.0,
      trustLevel: TRUST_LEVELS.GHOST,
      _flags: flags
    };
  }

  // Check if word is in reference (using canonical form)
  const normalized = normalizeWord(word.word);
  const canonical = getCanonical(normalized);
  const inReference = referenceSet.has(normalized) || referenceSet.has(canonical);

  // Get default model's confidence from _debug (per CONTEXT.md: use default only)
  const defaultConf = word._debug?.default?.confidence ?? word.confidence;

  let confidence;
  let trustLevel;

  switch (word.source) {
    case 'both':
      // Both models agree - use default's confidence as-is
      confidence = defaultConf;
      trustLevel = getTrustLevel(confidence);
      break;

    case 'latest_only':
      if (inReference) {
        // Stronger model caught quiet speech - benefit of doubt
        confidence = CONFIDENCE_THRESHOLDS.VALID_MUMBLE; // 0.85
        trustLevel = getTrustLevel(confidence); // Will be MEDIUM (0.85 >= 0.70)
      } else {
        // Hallucination risk - flag as possible insertion
        confidence = CONFIDENCE_THRESHOLDS.HALLUCINATION_RISK; // 0.50
        trustLevel = TRUST_LEVELS.LOW; // 0.50 < 0.70
        flags.push(CONFIDENCE_FLAGS.POSSIBLE_INSERTION);
      }
      break;

    case 'default_only':
      confidence = defaultConf;
      if (inReference) {
        // Student said it but unclearly - use confidence but CAP at MEDIUM
        const rawLevel = getTrustLevel(confidence);
        trustLevel = rawLevel === TRUST_LEVELS.HIGH ? TRUST_LEVELS.MEDIUM : rawLevel;
      } else {
        // Phantom from weaker model - LOW trust regardless of confidence
        trustLevel = TRUST_LEVELS.LOW;
        flags.push(CONFIDENCE_FLAGS.DEFAULT_ONLY_NOT_IN_REF);
      }
      break;

    default:
      // Fallback for unexpected source values
      confidence = word.confidence;
      trustLevel = getTrustLevel(confidence);
  }

  return {
    confidence,
    trustLevel,
    _flags: flags.length > 0 ? flags : undefined
  };
}
```
  </action>
  <verify>
Browser console tests:
```javascript
import { classifyWordConfidence, buildReferenceSet } from './js/confidence-classifier.js';
const ref = buildReferenceSet("The cat sat");

// Test: both models agree
let result = classifyWordConfidence({ word: 'cat', source: 'both', _debug: { default: { confidence: 0.95 } } }, ref);
console.assert(result.confidence === 0.95, 'both: uses default conf');
console.assert(result.trustLevel === 'high', 'both: high trust');

// Test: latest_only + in reference
result = classifyWordConfidence({ word: 'cat', source: 'latest_only', _debug: { latestLong: { confidence: 0.8 } } }, ref);
console.assert(result.confidence === 0.85, 'latest_only+ref: 0.85');
console.assert(result.trustLevel === 'medium', 'latest_only+ref: medium');

// Test: latest_only + NOT in reference
result = classifyWordConfidence({ word: 'dog', source: 'latest_only', _debug: {} }, ref);
console.assert(result.confidence === 0.50, 'latest_only+noref: 0.50');
console.assert(result.trustLevel === 'low', 'latest_only+noref: low');
console.assert(result._flags.includes('possible_insertion'), 'latest_only+noref: flagged');

// Test: VAD ghost
result = classifyWordConfidence({ word: 'cat', source: 'latest_only', vad_ghost_in_reference: true }, ref);
console.assert(result.confidence === 0.0, 'ghost: 0.0');
console.assert(result.trustLevel === 'ghost', 'ghost: ghost level');

console.log('classifyWordConfidence tests passed');
```
  </verify>
  <done>
- classifyWordConfidence() implements full asymmetric trust policy
- VAD ghost override works (confidence 0.0)
- Both models: uses default's confidence
- latest_only + in ref: 0.85 (VALID_MUMBLE)
- latest_only + NOT in ref: 0.50 + possible_insertion flag
- default_only: confidence from default, trustLevel capped/low
- Returns { confidence, trustLevel, _flags }
  </done>
</task>

<task type="auto">
  <name>Task 3: Create classifyAllWords batch function</name>
  <files>js/confidence-classifier.js</files>
  <action>
Add to js/confidence-classifier.js after classifyWordConfidence:

```javascript
/**
 * Classify all words and return new array with classification properties.
 * Does NOT mutate input array.
 *
 * @param {Array} mergedWords - Words from ensemble-merger with source tags
 * @param {string} referenceText - Reference passage text
 * @returns {Array} New array with confidence, trustLevel, _flags added to each word
 */
export function classifyAllWords(mergedWords, referenceText) {
  if (!mergedWords || mergedWords.length === 0) {
    return [];
  }

  const referenceSet = buildReferenceSet(referenceText);

  return mergedWords.map(word => {
    const classification = classifyWordConfidence(word, referenceSet);

    return {
      ...word,
      confidence: classification.confidence,
      trustLevel: classification.trustLevel,
      _flags: classification._flags
    };
  });
}

/**
 * Filter out ghost words (confidence === 0.0) from classified array.
 * Call this AFTER classifyAllWords, BEFORE alignment.
 *
 * @param {Array} classifiedWords - Words with trustLevel property
 * @returns {Array} Words with trustLevel !== 'ghost'
 */
export function filterGhosts(classifiedWords) {
  return classifiedWords.filter(w => w.trustLevel !== TRUST_LEVELS.GHOST);
}

/**
 * Compute classification statistics.
 * @param {Array} classifiedWords
 * @returns {object} Stats object
 */
export function computeClassificationStats(classifiedWords) {
  const stats = {
    total: classifiedWords.length,
    high: 0,
    medium: 0,
    low: 0,
    ghost: 0,
    possibleInsertions: 0
  };

  for (const w of classifiedWords) {
    if (w.trustLevel === TRUST_LEVELS.HIGH) stats.high++;
    else if (w.trustLevel === TRUST_LEVELS.MEDIUM) stats.medium++;
    else if (w.trustLevel === TRUST_LEVELS.LOW) stats.low++;
    else if (w.trustLevel === TRUST_LEVELS.GHOST) stats.ghost++;

    if (w._flags?.includes(CONFIDENCE_FLAGS.POSSIBLE_INSERTION)) {
      stats.possibleInsertions++;
    }
  }

  return stats;
}
```
  </action>
  <verify>
Browser console tests:
```javascript
import { classifyAllWords, filterGhosts, computeClassificationStats } from './js/confidence-classifier.js';

const words = [
  { word: 'the', source: 'both', _debug: { default: { confidence: 0.95 } } },
  { word: 'cat', source: 'latest_only', _debug: {} },
  { word: 'ghost', source: 'latest_only', vad_ghost_in_reference: true }
];

const classified = classifyAllWords(words, "The cat sat");
console.assert(classified.length === 3, 'All words classified');
console.assert(classified[0].trustLevel === 'high', 'First word high');
console.assert(classified[2].trustLevel === 'ghost', 'Ghost word');

const filtered = filterGhosts(classified);
console.assert(filtered.length === 2, 'Ghost filtered out');

const stats = computeClassificationStats(classified);
console.assert(stats.ghost === 1, 'Stats: 1 ghost');

console.log('classifyAllWords tests passed');
```
  </verify>
  <done>
- classifyAllWords() processes full word array
- Does NOT mutate input (returns new array)
- filterGhosts() removes words with trustLevel === 'ghost'
- computeClassificationStats() provides counts
- All functions exported
  </done>
</task>

</tasks>

<verification>
1. js/confidence-classifier.js loads without errors
2. buildReferenceSet() expands homophones and numbers
3. classifyWordConfidence() implements all trust policy rules
4. classifyAllWords() processes batch without mutation
5. filterGhosts() removes confidence=0 words
6. Existing app functionality unaffected (module not yet integrated)
</verification>

<success_criteria>
- Asymmetric trust policy fully implemented
- latest_only + in ref = 0.85 confidence
- latest_only + NOT in ref = 0.50 + possible_insertion flag
- VAD ghosts = 0.0 confidence, 'ghost' trustLevel
- Reference matching uses homophones and number equivalences
- No mutation of input data
</success_criteria>

<output>
After completion, create `.planning/phases/13-confidence-classification/13-02-SUMMARY.md`
</output>
