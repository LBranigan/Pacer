---
phase: 13-confidence-classification
plan: 03
type: execute
wave: 3
depends_on: ["13-02"]
files_modified:
  - js/app.js
autonomous: true

must_haves:
  truths:
    - "Classification runs AFTER ghost detection, BEFORE alignment"
    - "Ghost words (confidence 0.0) are filtered out before alignment"
    - "Classified words have trustLevel property visible in _debug data"
    - "Possible insertions have _flags array with 'possible_insertion'"
  artifacts:
    - path: "js/app.js"
      provides: "Classification step integrated into assessment flow"
      contains: "classifyAllWords"
  key_links:
    - from: "js/app.js"
      to: "js/confidence-classifier.js"
      via: "import and call in handleAnalyze"
      pattern: "import.*classifyAllWords.*filterGhosts"
---

<objective>
Integrate confidence classifier into app.js assessment flow, inserting classification after ghost detection and filtering ghosts before alignment.

Purpose: Prevent hallucinations from warping WCPM scores by classifying and filtering before alignment runs.
Output: Modified js/app.js with classification step in handleAnalyze()
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-confidence-classification/13-CONTEXT.md
@.planning/phases/13-confidence-classification/13-02-SUMMARY.md

@js/app.js
@js/confidence-classifier.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add confidence classifier imports to app.js</name>
  <files>js/app.js</files>
  <action>
At the top of js/app.js, add import for confidence classifier (near other imports around lines 4-18):

```javascript
import { classifyAllWords, filterGhosts, computeClassificationStats } from './confidence-classifier.js';
```

Place this import after the ghost-detector import for logical grouping:
```javascript
import { flagGhostWords } from './ghost-detector.js';
import { classifyAllWords, filterGhosts, computeClassificationStats } from './confidence-classifier.js';
```
  </action>
  <verify>
Browser console should show no import errors when app loads.
Check Network tab shows confidence-classifier.js loaded.
  </verify>
  <done>
- Import statement added to app.js
- No console errors on page load
- Module loads successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Insert classification step in handleAnalyze flow</name>
  <files>js/app.js</files>
  <action>
In handleAnalyze() function, AFTER ghost detection (around line 178) and BEFORE converting to STT response format (around line 188), insert the classification step.

Find this section (after ghost detection logging):
```javascript
      if (ghostResult.ghostCount > 0) {
        console.log(`[ORF] Ghost detection: ${ghostResult.ghostCount} potential hallucinations flagged`);
      }
    } else {
      addWarning('VAD not loaded', { error: vadProcessor.loadError });
      console.warn('[ORF] VAD not loaded, skipping ghost detection:', vadProcessor.loadError);
    }

    // Convert merged words to STT response format for compatibility
```

Insert classification step between ghost detection and STT response conversion:

```javascript
      if (ghostResult.ghostCount > 0) {
        console.log(`[ORF] Ghost detection: ${ghostResult.ghostCount} potential hallucinations flagged`);
      }
    } else {
      addWarning('VAD not loaded', { error: vadProcessor.loadError });
      console.warn('[ORF] VAD not loaded, skipping ghost detection:', vadProcessor.loadError);
    }

    // Confidence classification (Phase 13)
    // Pipeline: Classify -> Filter ghosts -> Align
    setStatus('Classifying word confidence...');
    const referenceText = document.getElementById('transcript').value.trim();
    const classifiedWords = classifyAllWords(mergedWords, referenceText);
    const classificationStats = computeClassificationStats(classifiedWords);

    addStage('confidence_classification', {
      total: classificationStats.total,
      high: classificationStats.high,
      medium: classificationStats.medium,
      low: classificationStats.low,
      ghost: classificationStats.ghost,
      possibleInsertions: classificationStats.possibleInsertions
    });

    // Filter ghost words BEFORE alignment (confidence === 0.0)
    const wordsForAlignment = filterGhosts(classifiedWords);

    if (classificationStats.ghost > 0) {
      console.log(`[ORF] Filtered ${classificationStats.ghost} ghost words before alignment`);
    }
    if (classificationStats.possibleInsertions > 0) {
      console.log(`[ORF] ${classificationStats.possibleInsertions} possible insertions flagged (not filtered)`);
    }

    // Convert merged words to STT response format for compatibility
    // (existing code expects data.results structure)
    // NOTE: Use classifiedWords (not filtered) to preserve all data for debugging
    // The aligner will receive wordsForAlignment (ghosts removed)
    data = {
      results: [{
        alternatives: [{
          words: classifiedWords,  // Keep all words including ghosts for _debug
          transcript: wordsForAlignment.map(w => w.word).join(' ')  // Transcript without ghosts
        }]
      }],
      _ensemble: {
        raw: ensembleResult,
        stats: ensembleStats
      },
      _vad: {
        segments: vadResult.segments,
        durationMs: vadResult.durationMs,
        ghostCount: ghostResult.ghostCount,
        hasGhostSequence: ghostResult.hasGhostSequence,
        error: vadResult.error || ghostResult.vadError
      },
      _classification: {
        stats: classificationStats,
        filteredForAlignment: wordsForAlignment.length
      }
    };
```

IMPORTANT: The data.results[0].alternatives[0].words should contain classifiedWords (full data), but alignment should use wordsForAlignment. This requires modifying the alignment call below.
  </action>
  <verify>
Run an assessment:
1. Open browser, load app
2. Enter reference text: "The cat sat on the mat"
3. Record audio saying the reference
4. Check console for classification logs
5. Check debug log for confidence_classification stage
6. Verify ghost count matches expected
  </verify>
  <done>
- Classification step runs after ghost detection
- classificationStats logged to debug
- Ghost words filtered before alignment
- Console logs show classification activity
  </done>
</task>

<task type="auto">
  <name>Task 3: Update alignment to use filtered words</name>
  <files>js/app.js</files>
  <action>
The alignment call (alignWordsToText) currently receives words from data.results structure. We need to ensure it uses wordsForAlignment (ghosts filtered out) instead of the raw words.

Find the alignment call (search for "alignWordsToText" in handleAnalyze):

```javascript
const alignedResponse = alignWordsToText(data, referenceText);
```

This call extracts words from data.results[0].alternatives[0].words internally. To use filtered words, we have two options:

**Option A (Preferred - Minimal change):** Modify data structure so alignment sees filtered words:

After the classification block, update the data structure:
```javascript
data = {
  results: [{
    alternatives: [{
      words: wordsForAlignment,  // FILTERED words for alignment
      transcript: wordsForAlignment.map(w => w.word).join(' ')
    }]
  }],
  _ensemble: { ... },
  _vad: { ... },
  _classification: {
    stats: classificationStats,
    allWords: classifiedWords,  // Keep ALL words here for debugging
    filteredCount: classifiedWords.length - wordsForAlignment.length
  }
};
```

**Option B (Alternative):** Modify alignWordsToText call to pass words directly.

Go with Option A - it maintains compatibility with existing alignment code.

Also ensure the final saved assessment preserves classification data. Find where assessment is saved and verify _classification is included in the saved data structure.
  </action>
  <verify>
Test alignment with ghost filtering:
1. Record audio with background noise (to trigger false positives)
2. Check that alignment receives fewer words than raw ensemble output
3. Verify _classification.allWords contains full word list
4. Verify results[0].alternatives[0].words contains filtered list
5. Verify WCPM calculation doesn't count filtered ghosts
  </verify>
  <done>
- Alignment receives wordsForAlignment (ghosts excluded)
- _classification.allWords preserves full data for debugging
- WCPM not inflated by ghost hallucinations
- Saved assessments include classification metadata
  </done>
</task>

</tasks>

<verification>
1. App loads without errors
2. Console shows "Classifying word confidence..." status
3. Debug log contains confidence_classification stage
4. Ghost words filtered before alignment
5. WCPM calculation excludes ghost words
6. Assessment data includes _classification metadata
7. Possible insertions visible in word data (_flags array)
</verification>

<success_criteria>
- Classification pipeline: Classify -> Filter -> Align
- Ghost words (confidence 0.0) do not affect WCPM
- Possible insertions flagged but not filtered (kept for teacher review)
- Debug data preserves full classification info
- No regression in existing assessment flow
</success_criteria>

<output>
After completion, create `.planning/phases/13-confidence-classification/13-03-SUMMARY.md`
</output>
