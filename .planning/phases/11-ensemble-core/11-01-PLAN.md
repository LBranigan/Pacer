---
phase: 11-ensemble-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/stt-api.js
autonomous: true

must_haves:
  truths:
    - "Both latest_long and default models are called for the same audio"
    - "API calls happen in parallel (not sequential)"
    - "If one model fails, the other result is still returned"
  artifacts:
    - path: "js/stt-api.js"
      provides: "sendEnsembleSTT function"
      exports: ["sendEnsembleSTT"]
  key_links:
    - from: "sendEnsembleSTT"
      to: "Promise.allSettled"
      via: "parallel API calls"
      pattern: "Promise\\.allSettled"
    - from: "sendEnsembleSTT"
      to: "getDefaultModelConfig"
      via: "default model config"
      pattern: "getDefaultModelConfig"
---

<objective>
Add parallel STT API calling capability to stt-api.js.

Purpose: Enable the ensemble strategy by calling both `latest_long` and `default` models simultaneously. The parallel execution ensures no latency penalty compared to single-model calls.
Output: New `sendEnsembleSTT()` export that returns both model results.
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-ensemble-core/11-RESEARCH.md
@js/stt-api.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sendEnsembleSTT function</name>
  <files>js/stt-api.js</files>
  <action>
Add a new exported async function `sendEnsembleSTT(blob, encoding)` that:

1. Gets API key from `document.getElementById('apiKey').value.trim()`
2. Gets passage text from `document.getElementById('transcript').value.trim()`
3. Converts blob to base64 using existing `blobToBase64()`
4. Builds two configs:
   - `latestConfig` using existing `buildSTTConfig(encoding)`
   - `defaultConfig` using existing `getDefaultModelConfig(encoding, passageText)`
5. Fires BOTH API calls in parallel using `Promise.allSettled([...])`:
   - Both fetch to `https://speech.googleapis.com/v1/speech:recognize?key=...`
   - Both POST with JSON body: `{ config: ..., audio: { content: base64 } }`
   - Use `.then(r => r.json())` to parse responses
6. Returns an object:
   ```javascript
   {
     latestLong: latestResult.status === 'fulfilled' ? latestResult.value : null,
     default: defaultResult.status === 'fulfilled' ? defaultResult.value : null,
     errors: {
       latestLong: latestResult.status === 'rejected' ? latestResult.reason?.message : null,
       default: defaultResult.status === 'rejected' ? defaultResult.reason?.message : null
     }
   }
   ```

Add the export to the module: `export { sendEnsembleSTT }` (alongside existing exports).

IMPORTANT:
- Use `Promise.allSettled` NOT `Promise.all` (we want both results even if one fails)
- Do NOT call `setStatus()` from this function - let caller handle UI
- If API key is missing, return `{ latestLong: null, default: null, errors: { api: 'No API key' } }`
  </action>
  <verify>
Verify function exists and is exported:
```bash
grep -n "sendEnsembleSTT" js/stt-api.js
grep -n "Promise.allSettled" js/stt-api.js
```
Both should show matches.
  </verify>
  <done>
- `sendEnsembleSTT` function exists in js/stt-api.js
- Function uses `Promise.allSettled` for parallel calls
- Function is exported from the module
- Function handles missing API key gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Add helper for raw STT fetch</name>
  <files>js/stt-api.js</files>
  <action>
Extract the raw fetch logic into a reusable internal helper to avoid duplication in sendEnsembleSTT:

```javascript
/**
 * Raw STT API call (internal helper).
 * @param {string} base64 - Base64 encoded audio
 * @param {object} config - STT config object
 * @param {string} apiKey - Google Cloud API key
 * @returns {Promise<object>} STT response JSON
 */
async function fetchSTTRaw(base64, config, apiKey) {
  const resp = await fetch(
    'https://speech.googleapis.com/v1/speech:recognize?key=' + encodeURIComponent(apiKey),
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ config, audio: { content: base64 } })
    }
  );
  const data = await resp.json();
  if (data.error) {
    throw new Error(data.error.message || 'STT API error');
  }
  return data;
}
```

Do NOT export this function - it's internal only. Keep it near the top of the file after `blobToBase64`.

Then update `sendEnsembleSTT` to use this helper for cleaner code:
```javascript
const [latestResult, defaultResult] = await Promise.allSettled([
  fetchSTTRaw(base64, latestConfig, apiKey),
  fetchSTTRaw(base64, defaultConfig, apiKey)
]);
```
  </action>
  <verify>
Verify helper exists and sendEnsembleSTT uses it:
```bash
grep -n "fetchSTTRaw" js/stt-api.js
```
Should show function definition and usages.
  </verify>
  <done>
- `fetchSTTRaw` internal helper exists
- `sendEnsembleSTT` uses the helper for both API calls
- Helper throws on API error (propagates to Promise.allSettled rejection)
  </done>
</task>

</tasks>

<verification>
Run these checks to verify the plan is complete:

1. Function exists and is exported:
```bash
grep -n "export.*sendEnsembleSTT\|sendEnsembleSTT.*export" js/stt-api.js
```

2. Uses Promise.allSettled (not Promise.all):
```bash
grep -n "Promise.allSettled" js/stt-api.js
```

3. Uses both model configs:
```bash
grep -n "buildSTTConfig\|getDefaultModelConfig" js/stt-api.js | wc -l
```
Should show at least 3 (original buildSTTConfig usage + both in ensemble)

4. File has no syntax errors:
```bash
node --check js/stt-api.js
```
</verification>

<success_criteria>
- js/stt-api.js exports `sendEnsembleSTT` function
- Function calls both `latest_long` and `default` models in parallel via `Promise.allSettled`
- Function returns structured result with both responses (or null if failed)
- Function uses existing `buildSTTConfig` and `getDefaultModelConfig` for configs
- File passes Node.js syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/11-ensemble-core/11-01-SUMMARY.md`
</output>
