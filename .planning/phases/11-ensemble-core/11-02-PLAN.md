---
phase: 11-ensemble-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - js/ensemble-merger.js
autonomous: true

must_haves:
  truths:
    - "Words are matched by temporal overlap, not text content"
    - "50ms jitter tolerance handles timestamp drift between models"
    - "Each merged word includes source tag: both, latest_only, or default_only"
    - "Each merged word has _debug property with both model results"
  artifacts:
    - path: "js/ensemble-merger.js"
      provides: "Temporal word association and merge logic"
      exports: ["mergeEnsembleResults", "extractWordsFromSTT"]
  key_links:
    - from: "mergeEnsembleResults"
      to: "timeOverlap"
      via: "interval overlap detection"
      pattern: "Math\\.max.*Math\\.min"
---

<objective>
Create the temporal word association algorithm in a new module.

Purpose: Associate words from two STT transcripts by their timestamp overlap (not text matching). This handles stutters and disfluencies correctly since "th-th-the" from one model won't text-match "the" from another.
Output: New `ensemble-merger.js` module with `mergeEnsembleResults()` and `extractWordsFromSTT()` exports.
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-ensemble-core/11-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ensemble-merger.js with core functions</name>
  <files>js/ensemble-merger.js</files>
  <action>
Create a new file `js/ensemble-merger.js` with the following structure:

```javascript
/**
 * Ensemble transcript merger with temporal word association.
 * Associates words from two STT models by timestamp overlap, not text content.
 */

const JITTER_MS = 50; // Tolerance for CTC vs Conformer timestamp drift

/**
 * Parse Google STT timestamp string to milliseconds.
 * @param {string|number} t - Timestamp like "1.400s" or number
 * @returns {number} Milliseconds
 */
function parseTimeMs(t) {
  if (typeof t === 'number') return t * 1000;
  return (parseFloat(String(t).replace('s', '')) || 0) * 1000;
}

/**
 * Check if two words have temporal overlap within jitter tolerance.
 * @param {object} word1 - Word with startTime/endTime
 * @param {object} word2 - Word with startTime/endTime
 * @param {number} jitterMs - Tolerance in milliseconds
 * @returns {boolean} True if words overlap
 */
function timeOverlap(word1, word2, jitterMs = JITTER_MS) {
  const start1 = parseTimeMs(word1.startTime);
  const end1 = parseTimeMs(word1.endTime);
  const start2 = parseTimeMs(word2.startTime) - jitterMs; // Expand word2 window
  const end2 = parseTimeMs(word2.endTime) + jitterMs;

  // Overlap exists if: max(start1, adjustedStart2) < min(end1, adjustedEnd2)
  return Math.max(start1, start2) < Math.min(end1, end2);
}

/**
 * Create a merged word structure with debug data.
 * @param {object|null} latestWord - Word from latest_long model
 * @param {object|null} defaultWord - Word from default model
 * @returns {object} Merged word with source tag and _debug
 */
function createMergedWord(latestWord, defaultWord) {
  // Determine source tag
  let source;
  if (latestWord && defaultWord) {
    source = 'both';
  } else if (latestWord) {
    source = 'latest_only';
  } else {
    source = 'default_only';
  }

  // Primary word comes from latest_long when available (better for rare words)
  const primary = latestWord || defaultWord;

  return {
    word: primary.word,
    startTime: primary.startTime,
    endTime: primary.endTime,
    confidence: primary.confidence,
    source: source,
    _debug: {
      latestLong: latestWord ? {
        word: latestWord.word,
        startTime: latestWord.startTime,
        endTime: latestWord.endTime,
        confidence: latestWord.confidence
      } : null,
      default: defaultWord ? {
        word: defaultWord.word,
        startTime: defaultWord.startTime,
        endTime: defaultWord.endTime,
        confidence: defaultWord.confidence
      } : null
    }
  };
}

/**
 * Extract words array from STT API response.
 * @param {object} sttResponse - Google STT response object
 * @returns {Array} Array of word objects
 */
export function extractWordsFromSTT(sttResponse) {
  if (!sttResponse || !sttResponse.results) return [];

  const words = [];
  for (const result of sttResponse.results) {
    const alt = result.alternatives && result.alternatives[0];
    if (alt && alt.words) {
      for (const w of alt.words) {
        words.push(w);
      }
    }
  }
  return words;
}

/**
 * Merge two STT results using temporal word association.
 * @param {object} ensembleResult - Result from sendEnsembleSTT
 * @returns {Array} Array of merged words with source tags and _debug data
 */
export function mergeEnsembleResults(ensembleResult) {
  const latestWords = extractWordsFromSTT(ensembleResult.latestLong);
  const defaultWords = extractWordsFromSTT(ensembleResult.default);

  // Handle edge cases
  if (latestWords.length === 0 && defaultWords.length === 0) {
    return [];
  }
  if (latestWords.length === 0) {
    return defaultWords.map(w => createMergedWord(null, w));
  }
  if (defaultWords.length === 0) {
    return latestWords.map(w => createMergedWord(w, null));
  }

  // Temporal word association
  const merged = [];
  const usedDefault = new Set();

  // For each latest_long word, find overlapping default word
  for (const lw of latestWords) {
    let matchedDefault = null;

    for (let i = 0; i < defaultWords.length; i++) {
      if (usedDefault.has(i)) continue;

      if (timeOverlap(lw, defaultWords[i], JITTER_MS)) {
        matchedDefault = defaultWords[i];
        usedDefault.add(i);
        break; // Take first match (words are time-ordered)
      }
    }

    merged.push(createMergedWord(lw, matchedDefault));
  }

  // Add any unmatched default words (default_only)
  for (let i = 0; i < defaultWords.length; i++) {
    if (!usedDefault.has(i)) {
      merged.push(createMergedWord(null, defaultWords[i]));
    }
  }

  // Sort by timestamp
  merged.sort((a, b) => parseTimeMs(a.startTime) - parseTimeMs(b.startTime));

  return merged;
}
```

IMPORTANT:
- Export ONLY `mergeEnsembleResults` and `extractWordsFromSTT`
- Keep internal functions (`parseTimeMs`, `timeOverlap`, `createMergedWord`) private
- Use JITTER_MS = 50 as per STATE.md decision
- Handle null/empty results gracefully (fall back to whichever model has data)
  </action>
  <verify>
Verify file exists with correct exports:
```bash
ls -la js/ensemble-merger.js
grep -n "^export" js/ensemble-merger.js
node --check js/ensemble-merger.js
```
  </verify>
  <done>
- New file js/ensemble-merger.js exists
- Exports `mergeEnsembleResults` and `extractWordsFromSTT`
- Uses temporal overlap (not text matching) for word association
- Includes _debug property on each merged word
- Tags words with source: both, latest_only, or default_only
- File passes Node.js syntax check
  </done>
</task>

<task type="auto">
  <name>Task 2: Add statistics to merged result</name>
  <files>js/ensemble-merger.js</files>
  <action>
Add a helper function to compute ensemble statistics and enhance `mergeEnsembleResults` to optionally return stats:

After the `mergeEnsembleResults` function, add:

```javascript
/**
 * Compute statistics about the ensemble merge.
 * @param {Array} mergedWords - Result from mergeEnsembleResults
 * @returns {object} Statistics object
 */
export function computeEnsembleStats(mergedWords) {
  const stats = {
    totalWords: mergedWords.length,
    both: 0,
    latestOnly: 0,
    defaultOnly: 0,
    agreementRate: 0
  };

  for (const w of mergedWords) {
    if (w.source === 'both') stats.both++;
    else if (w.source === 'latest_only') stats.latestOnly++;
    else if (w.source === 'default_only') stats.defaultOnly++;
  }

  stats.agreementRate = stats.totalWords > 0
    ? Math.round((stats.both / stats.totalWords) * 100)
    : 0;

  return stats;
}
```

This function is useful for debugging and UI display (Phase 16) to show model agreement.
  </action>
  <verify>
```bash
grep -n "computeEnsembleStats" js/ensemble-merger.js
grep -n "^export" js/ensemble-merger.js
```
Should show the function and 3 exports total.
  </verify>
  <done>
- `computeEnsembleStats` function exists and is exported
- Returns object with totalWords, both, latestOnly, defaultOnly, agreementRate
- Module now has 3 exports: mergeEnsembleResults, extractWordsFromSTT, computeEnsembleStats
  </done>
</task>

</tasks>

<verification>
Run these checks to verify the plan is complete:

1. File exists and has correct exports:
```bash
grep -n "^export" js/ensemble-merger.js
```
Should show 3 export lines (mergeEnsembleResults, extractWordsFromSTT, computeEnsembleStats)

2. Uses temporal overlap pattern:
```bash
grep -n "Math.max.*Math.min\|timeOverlap" js/ensemble-merger.js
```

3. Has _debug property in merged words:
```bash
grep -n "_debug" js/ensemble-merger.js
```

4. Has source tags:
```bash
grep -n "latest_only\|default_only\|both" js/ensemble-merger.js
```

5. File passes syntax check:
```bash
node --check js/ensemble-merger.js
```
</verification>

<success_criteria>
- js/ensemble-merger.js exists with 3 exports
- `mergeEnsembleResults` uses temporal overlap (50ms jitter) for word association
- Merged words have `source` property: 'both', 'latest_only', or 'default_only'
- Merged words have `_debug` property with both model results
- `computeEnsembleStats` returns agreement metrics
- File passes Node.js syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/11-ensemble-core/11-02-SUMMARY.md`
</output>
