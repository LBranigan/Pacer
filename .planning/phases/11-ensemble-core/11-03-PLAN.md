---
phase: 11-ensemble-core
plan: 03
type: execute
wave: 2
depends_on:
  - "11-01"
  - "11-02"
files_modified:
  - js/app.js
  - index.html
autonomous: true

must_haves:
  truths:
    - "Assessment flow uses ensemble STT instead of single-model STT"
    - "Merged transcript words have source tags visible in debug log"
    - "Both model results preserved in assessment data"
    - "UI continues to work (alignment, metrics, diagnostics)"
  artifacts:
    - path: "js/app.js"
      provides: "Integrated ensemble flow"
      contains: "sendEnsembleSTT"
  key_links:
    - from: "js/app.js"
      to: "sendEnsembleSTT"
      via: "import and call"
      pattern: "import.*sendEnsembleSTT"
    - from: "js/app.js"
      to: "mergeEnsembleResults"
      via: "import and call"
      pattern: "import.*mergeEnsembleResults"
---

<objective>
Integrate ensemble STT into the main assessment flow.

Purpose: Replace single-model STT calls with ensemble calls so every assessment benefits from two-model corroboration. The existing alignment, metrics, and diagnostics continue to work with the merged transcript.
Output: Updated app.js using ensemble flow for sync recordings (<60s).
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-ensemble-core/11-RESEARCH.md
@.planning/phases/11-ensemble-core/11-01-SUMMARY.md
@.planning/phases/11-ensemble-core/11-02-SUMMARY.md
@js/app.js
@js/stt-api.js
@js/ensemble-merger.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ensemble imports to app.js</name>
  <files>js/app.js</files>
  <action>
Update the imports at the top of app.js:

1. Add `sendEnsembleSTT` to the stt-api.js import:
```javascript
import { sendToSTT, sendToAsyncSTT, sendChunkedSTT, sendEnsembleSTT } from './stt-api.js';
```

2. Add new import for ensemble-merger.js:
```javascript
import { mergeEnsembleResults, extractWordsFromSTT, computeEnsembleStats } from './ensemble-merger.js';
```

Place this import after the stt-api.js import line.
  </action>
  <verify>
```bash
grep -n "sendEnsembleSTT" js/app.js
grep -n "mergeEnsembleResults" js/app.js
```
Both should show import lines.
  </verify>
  <done>
- app.js imports sendEnsembleSTT from stt-api.js
- app.js imports mergeEnsembleResults, extractWordsFromSTT, computeEnsembleStats from ensemble-merger.js
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify runAnalysis to use ensemble for sync path</name>
  <files>js/app.js</files>
  <action>
In the `runAnalysis()` function, modify the sync path (the else branch around line 121-124) to use ensemble:

BEFORE (approximately lines 121-124):
```javascript
} else {
  setStatus('Sending audio to STT...');
  data = await sendToSTT(appState.audioBlob, appState.audioEncoding);
}
```

AFTER:
```javascript
} else {
  setStatus('Running ensemble STT analysis...');
  const ensembleResult = await sendEnsembleSTT(appState.audioBlob, appState.audioEncoding);

  // Log ensemble result for debugging
  addStage('ensemble_raw', {
    hasLatestLong: !!ensembleResult.latestLong,
    hasDefault: !!ensembleResult.default,
    errors: ensembleResult.errors
  });

  // Check for complete failure
  if (!ensembleResult.latestLong && !ensembleResult.default) {
    setStatus('Both STT models failed. Check API key.');
    analyzeBtn.disabled = false;
    finalizeDebugLog({ error: 'Both STT models failed', details: ensembleResult.errors });
    return;
  }

  // Merge results using temporal word association
  const mergedWords = mergeEnsembleResults(ensembleResult);
  const ensembleStats = computeEnsembleStats(mergedWords);

  addStage('ensemble_merged', {
    totalWords: ensembleStats.totalWords,
    both: ensembleStats.both,
    latestOnly: ensembleStats.latestOnly,
    defaultOnly: ensembleStats.defaultOnly,
    agreementRate: ensembleStats.agreementRate
  });

  // Convert merged words to STT response format for compatibility
  // (existing code expects data.results structure)
  data = {
    results: [{
      alternatives: [{
        words: mergedWords,
        transcript: mergedWords.map(w => w.word).join(' ')
      }]
    }],
    _ensemble: {
      raw: ensembleResult,
      stats: ensembleStats
    }
  };
}
```

NOTE: The async path (lines 105-120) remains unchanged for now. Ensemble will be extended to async in a future phase if needed.
  </action>
  <verify>
```bash
grep -n "sendEnsembleSTT\|mergeEnsembleResults\|ensembleStats" js/app.js
```
Should show multiple matches in the runAnalysis function.
  </verify>
  <done>
- Sync path uses sendEnsembleSTT instead of sendToSTT
- Ensemble results are merged using mergeEnsembleResults
- Stats are computed with computeEnsembleStats
- Merged words converted to compatible data.results format
- Debug logging captures ensemble_raw and ensemble_merged stages
- Graceful handling when both models fail
  </done>
</task>

<task type="auto">
  <name>Task 3: Preserve ensemble data in saved assessment</name>
  <files>js/app.js</files>
  <action>
Update the saveAssessment call (around line 453-466) to include ensemble data:

Find the saveAssessment call and add the _ensemble field:

```javascript
saveAssessment(appState.selectedStudentId, {
  _id: assessmentId,
  wcpm: wcpm ? wcpm.wcpm : null,
  accuracy: accuracy.accuracy,
  totalWords: accuracy.totalRefWords,
  errors: accuracy.substitutions + accuracy.omissions,
  duration: effectiveElapsedSeconds,
  passagePreview: referenceText.slice(0, 60),
  errorBreakdown,
  alignment,
  sttWords: transcriptWords,
  audioRef: appState.audioBlob ? assessmentId : null,
  nlAnnotations,
  _ensemble: data._ensemble || null  // Add this line - preserves ensemble debug data
});
```

This preserves the raw ensemble results and stats in the saved assessment for later analysis.
  </action>
  <verify>
```bash
grep -n "_ensemble" js/app.js
```
Should show at least 2 matches (creation in runAnalysis and save in saveAssessment).
  </verify>
  <done>
- saveAssessment includes _ensemble field
- Ensemble raw results and stats are preserved in saved assessment data
- Field is null for non-ensemble assessments (async path)
  </done>
</task>

</tasks>

<verification>
Run these checks to verify the plan is complete:

1. Imports are correct:
```bash
grep -n "import.*sendEnsembleSTT" js/app.js
grep -n "import.*mergeEnsembleResults" js/app.js
```

2. Ensemble flow is in place:
```bash
grep -n "sendEnsembleSTT\|mergeEnsembleResults\|computeEnsembleStats" js/app.js | wc -l
```
Should show 4+ matches (2 imports + 2+ usages)

3. Debug stages added:
```bash
grep -n "ensemble_raw\|ensemble_merged" js/app.js
```

4. _ensemble preserved in save:
```bash
grep -n "_ensemble.*data\._ensemble" js/app.js
```

5. File passes syntax check:
```bash
node --check js/app.js
```

6. Update version timestamp in index.html
</verification>

<success_criteria>
- app.js imports sendEnsembleSTT from stt-api.js
- app.js imports mergeEnsembleResults, extractWordsFromSTT, computeEnsembleStats from ensemble-merger.js
- Sync path (<60s recordings) uses ensemble flow
- Debug log captures ensemble_raw and ensemble_merged stages
- Saved assessments include _ensemble field with raw results and stats
- Existing functionality (alignment, metrics, diagnostics, UI) continues to work
- File passes Node.js syntax check
- index.html version timestamp updated
</success_criteria>

<output>
After completion, create `.planning/phases/11-ensemble-core/11-03-SUMMARY.md`
</output>
