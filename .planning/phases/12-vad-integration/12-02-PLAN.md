---
phase: 12-vad-integration
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - js/ghost-detector.js
autonomous: true

must_haves:
  truths:
    - "Words tagged as latest_only + in reference + no VAD overlap get flagged as vad_ghost_in_reference"
    - "Short words (<200ms) use lenient 30ms overlap threshold"
    - "Words at audio edges (first/last 300ms) are NOT flagged as ghosts"
    - "Ghost detection is disabled when no reference text exists"
    - "5+ consecutive ghosts are tracked for UI escalation"
  artifacts:
    - path: "js/ghost-detector.js"
      provides: "Ghost detection logic for latest_only words"
      exports: ["flagGhostWords", "EDGE_TOLERANCE_MS"]
  key_links:
    - from: "js/ghost-detector.js"
      to: "ensemble-merger.js word.source"
      via: "checks word.source === 'latest_only'"
      pattern: "word\\.source.*latest_only"
    - from: "js/ghost-detector.js"
      to: "VAD segments"
      via: "overlap calculation between word timestamps and VAD segments"
      pattern: "Math\\.max.*Math\\.min"
---

<objective>
Implement ghost word detection logic that compares `latest_only` word timestamps against VAD speech segments.

Purpose: The core "Ghost Buster" logic that detects hallucinated words. When the ASR reports a word but VAD found no speech during that time window, the word is flagged as a potential ghost. This is the key innovation of Phase 12.

Output: `js/ghost-detector.js` module with flagGhostWords function
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-vad-integration/12-CONTEXT.md
@.planning/phases/12-vad-integration/12-RESEARCH.md

# Prior plan created VADProcessor
@.planning/phases/12-vad-integration/12-01-PLAN.md

# Source files to understand word structure
@js/ensemble-merger.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ghost-detector.js with timestamp parsing utilities</name>
  <files>js/ghost-detector.js</files>
  <action>
Create new ES module `js/ghost-detector.js` with:

1. **Constants**:
```javascript
export const EDGE_TOLERANCE_MS = 300;  // First/last 300ms of recording - be lenient
const OVERLAP_DEFAULT_MS = 50;          // Normal words need 50ms VAD overlap
const OVERLAP_SHORT_WORD_MS = 30;       // Short words (<200ms) need only 30ms
const SHORT_WORD_DURATION_MS = 200;     // Threshold for "short word"
const GHOST_SEQUENCE_THRESHOLD = 5;     // 5+ consecutive = escalated flagging
```

2. **Helper function** `parseTimeMs(t)`:
   - If t is a number, multiply by 1000 (Google STT uses seconds)
   - If t is a string like "1.400s", parse and multiply by 1000
   - Return milliseconds

3. **Helper function** `isAtAudioEdge(wordStartMs, wordEndMs, audioDurationMs)`:
   - Return true if wordStartMs < EDGE_TOLERANCE_MS
   - Return true if wordEndMs > audioDurationMs - EDGE_TOLERANCE_MS
   - Otherwise return false

4. **Helper function** `computeMaxOverlap(wordStartMs, wordEndMs, vadSegments)`:
   - Iterate through vadSegments
   - For each segment, compute overlap: `overlapStart = max(wordStart, seg.start)`, `overlapEnd = min(wordEnd, seg.end)`
   - If overlapStart < overlapEnd, overlap = overlapEnd - overlapStart
   - Track and return maximum overlap found
   - Return 0 if no overlaps

5. **Helper function** `normalizeWord(word)`:
   - Convert to lowercase
   - Remove leading/trailing non-alphanumeric except apostrophe and hyphen
   - Return normalized string for reference matching
  </action>
  <verify>Module compiles without errors. Helper functions can be tested in isolation.</verify>
  <done>Helper functions parseTimeMs, isAtAudioEdge, computeMaxOverlap, normalizeWord are implemented</done>
</task>

<task type="auto">
  <name>Task 2: Implement flagGhostWords main function</name>
  <files>js/ghost-detector.js</files>
  <action>
Add the main export function to ghost-detector.js:

```javascript
/**
 * Flag ghost words - latest_only words with no VAD speech overlap.
 * @param {Array} mergedWords - Words from ensemble-merger with source tags
 * @param {object} vadResult - Result from vadProcessor.processAudio()
 * @param {string} referenceText - Reference passage text (empty = skip detection)
 * @param {number} audioDurationMs - Total audio duration in milliseconds
 * @returns {object} { ghostCount, hasGhostSequence, vadError, ghostIndices }
 */
export function flagGhostWords(mergedWords, vadResult, referenceText, audioDurationMs) {
```

Implementation per CONTEXT.md decisions:

1. **VAD failure handling** (per "VAD failure: Warn and continue"):
   - If `!vadResult.segments || vadResult.error`, return `{ ghostCount: 0, hasGhostSequence: false, vadError: vadResult.error || 'No VAD segments', ghostIndices: [] }`

2. **No reference text** (per "No reference text: Disable ghost detection entirely"):
   - If `!referenceText || !referenceText.trim()`, return `{ ghostCount: 0, hasGhostSequence: false, vadError: null, ghostIndices: [] }`

3. **Build reference word set**:
   - Split referenceText on whitespace
   - Normalize each word using normalizeWord()
   - Create Set for O(1) lookup

4. **Iterate through mergedWords**:
   - Initialize: `ghostCount = 0`, `consecutiveGhosts = 0`, `maxConsecutive = 0`, `ghostIndices = []`
   - For each word at index i:
     - Initialize `word.vad_ghost_in_reference = false` (reset any previous flag)

     - **Skip if not latest_only**: `if (word.source !== 'latest_only') { consecutiveGhosts = 0; continue; }`

     - **Skip if NOT in reference** (per "only flag latest_only words that ARE in reference"):
       ```javascript
       const wordNorm = normalizeWord(word.word);
       if (!referenceSet.has(wordNorm)) { consecutiveGhosts = 0; continue; }
       ```

     - **Skip edge words** (per "Audio edges: Be lenient at start/end of recording"):
       ```javascript
       const wordStart = parseTimeMs(word.startTime);
       const wordEnd = parseTimeMs(word.endTime);
       if (isAtAudioEdge(wordStart, wordEnd, audioDurationMs)) { consecutiveGhosts = 0; continue; }
       ```

     - **Check VAD overlap**:
       ```javascript
       const wordDuration = wordEnd - wordStart;
       const maxOverlap = computeMaxOverlap(wordStart, wordEnd, vadResult.segments);
       const requiredOverlap = wordDuration < SHORT_WORD_DURATION_MS ? OVERLAP_SHORT_WORD_MS : OVERLAP_DEFAULT_MS;
       ```

     - **Trust if VAD sees anything** (per "Quiet speech: Trust if VAD sees anything"):
       ```javascript
       if (maxOverlap >= requiredOverlap) {
         consecutiveGhosts = 0;
         continue;  // VAD detected speech - not a ghost
       }
       ```

     - **Flag as ghost**:
       ```javascript
       word.vad_ghost_in_reference = true;
       ghostCount++;
       ghostIndices.push(i);
       consecutiveGhosts++;
       maxConsecutive = Math.max(maxConsecutive, consecutiveGhosts);
       ```

5. **Return results** (per "Ghost sequences: Escalate 5+ consecutive ghosts"):
   ```javascript
   return {
     ghostCount,
     hasGhostSequence: maxConsecutive >= GHOST_SEQUENCE_THRESHOLD,
     vadError: null,
     ghostIndices
   };
   ```
  </action>
  <verify>Create test cases: (1) word with VAD overlap not flagged, (2) word without VAD overlap flagged, (3) edge word not flagged, (4) word not in reference not flagged, (5) 5+ consecutive ghosts sets hasGhostSequence true</verify>
  <done>flagGhostWords correctly flags latest_only words in reference with no VAD overlap, respects edge tolerance, tracks consecutive sequences</done>
</task>

</tasks>

<verification>
1. Import ghost-detector.js in browser console or test file
2. Test with mock data:
   ```javascript
   const words = [
     { word: 'the', startTime: '0.5s', endTime: '0.7s', source: 'both' },
     { word: 'cat', startTime: '1.0s', endTime: '1.3s', source: 'latest_only' },
     { word: 'sat', startTime: '2.0s', endTime: '2.3s', source: 'latest_only' }
   ];
   const vadResult = { segments: [{ start: 400, end: 800 }, { start: 1900, end: 2400 }], error: null };
   const result = flagGhostWords(words, vadResult, 'the cat sat', 3000);
   // Expected: 'cat' flagged (no VAD at 1000-1300), 'sat' not flagged (VAD at 1900-2400 overlaps)
   ```
</verification>

<success_criteria>
- [x] js/ghost-detector.js exists with flagGhostWords export
- [x] latest_only words IN reference with no VAD overlap get `vad_ghost_in_reference = true`
- [x] latest_only words NOT in reference are NOT flagged
- [x] Words with ANY VAD overlap >= threshold are NOT flagged
- [x] Short words (<200ms) use lenient 30ms overlap threshold
- [x] Edge words (first/last 300ms) are NOT flagged
- [x] hasGhostSequence is true when 5+ consecutive ghosts detected
- [x] VAD errors return gracefully with vadError message
- [x] Empty reference text returns without flagging anything
</success_criteria>

<output>
After completion, create `.planning/phases/12-vad-integration/12-02-SUMMARY.md`
</output>
