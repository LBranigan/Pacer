---
phase: 21-sequence-alignment-disfluency
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/sequence-aligner.js
  - js/disfluency-tagger.js
autonomous: true

must_haves:
  truths:
    - "Verbatim and clean transcripts are globally aligned using Needleman-Wunsch"
    - "Words in verbatim but not in clean are identified as disfluencies"
    - "Filler words (um, uh, er, ah, mm, hmm) are classified as type filler"
    - "Consecutive repeated words are classified as type repetition"
    - "Partial words followed by complete word are classified as type false_start"
    - "Disfluency rate excludes disfluencies from denominator (WCPM integrity)"
  artifacts:
    - path: "js/sequence-aligner.js"
      provides: "Needleman-Wunsch global alignment algorithm"
      exports: ["alignTranscripts"]
      min_lines: 80
    - path: "js/disfluency-tagger.js"
      provides: "Disfluency classification and statistics"
      exports: ["tagDisfluencies", "computeDisfluencyStats"]
      min_lines: 60
  key_links:
    - from: "js/disfluency-tagger.js"
      to: "js/sequence-aligner.js"
      via: "imports alignTranscripts or receives alignment array"
      pattern: "type.*insertion|alignment"
---

<objective>
Implement Needleman-Wunsch sequence alignment and disfluency classification for comparing Reverb verbatim (v=1.0) and clean (v=0.0) transcripts.

Purpose: Reliably identify disfluencies (fillers, repetitions, false starts) from the difference between verbatim and clean Reverb transcripts, replacing the unreliable STT-timestamp-based approach in disfluency-detector.js.

Output: Two ES modules (`sequence-aligner.js`, `disfluency-tagger.js`) implementing DISF-01 through DISF-07 and INTG-03, INTG-04 requirements.
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Research (contains complete code examples)
@.planning/phases/21-sequence-alignment-disfluency/21-RESEARCH.md

# Existing patterns to follow
@js/alignment.js (existing diff-match-patch alignment - for export/JSDoc patterns)
@js/disfluency-detector.js (deprecated approach - see what NOT to do)
@js/text-normalize.js (existing DISFLUENCIES Set and normalizeText)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sequence-aligner.js with Needleman-Wunsch</name>
  <files>js/sequence-aligner.js</files>
  <action>
Create `js/sequence-aligner.js` implementing Needleman-Wunsch global sequence alignment.

**Requirements covered:** DISF-01 (NW alignment), DISF-02 (insertions = disfluencies), INTG-03 (sequence-aligner.js exists)

**Implementation:**
1. Use scoring parameters from research: match=2, mismatch=-1, gapInsert=-1, gapDelete=-2
2. Asymmetric gap penalties favor finding insertions (disfluencies) over deletions
3. Word normalization: lowercase, strip punctuation (match existing normalizeWord pattern in disfluency-detector.js)
4. Handle edge cases: both empty, one empty, identical transcripts

**Export:** `alignTranscripts(verbatimWords, cleanWords, options)`
- Input: arrays of word objects with {word, start_time, end_time}
- Output: array of alignment entries with {type, verbatim, clean, verbatimData?, cleanData?}
- Types: 'match', 'mismatch', 'insertion', 'deletion'

**Use the complete code example from 21-RESEARCH.md Pattern 1** as starting point.

**Do NOT:**
- Use external libraries (algorithm is 50-100 lines)
- Use timestamps for matching (the old failed approach)
- Import diff-match-patch (NW gives more control over gap penalties)
  </action>
  <verify>
Create inline test at bottom of file (commented out) that verifies:
```javascript
// Test: "the the cat" vs "the cat" should produce one insertion
const verbatim = [{word: 'the'}, {word: 'the'}, {word: 'cat'}];
const clean = [{word: 'the'}, {word: 'cat'}];
const result = alignTranscripts(verbatim, clean);
// Expected: [{type:'match', verbatim:'the', clean:'the'},
//            {type:'insertion', verbatim:'the', clean:null},
//            {type:'match', verbatim:'cat', clean:'cat'}]
```
Run: `node --experimental-vm-modules -e "import('./js/sequence-aligner.js')"` should not throw.
  </verify>
  <done>
- sequence-aligner.js exists with alignTranscripts export
- "the the cat" vs "the cat" alignment produces exactly one insertion at index 1
- Edge cases handled (empty arrays, identical arrays)
- JSDoc comments match existing codebase style (see alignment.js)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create disfluency-tagger.js with classification and stats</name>
  <files>js/disfluency-tagger.js</files>
  <action>
Create `js/disfluency-tagger.js` implementing disfluency classification from alignment results.

**Requirements covered:** DISF-03 (fillers), DISF-04 (repetitions), DISF-05 (false starts), DISF-06 (rate), DISF-07 (WCPM intact), INTG-04 (disfluency-tagger.js exists)

**Implementation:**
1. FILLER_WORDS Set: ['um', 'uh', 'er', 'ah', 'mm', 'hmm', 'hm', 'erm'] - extend existing text-normalize.js DISFLUENCIES Set
2. classifyDisfluency(entry, alignment, index):
   - Check FILLER_WORDS first -> 'filler'
   - Check adjacent words for same word -> 'repetition'
   - Check short word (1-3 chars) followed by longer word with same prefix -> 'false_start'
   - Default -> 'unknown'
3. tagDisfluencies(alignment) - adds disfluencyType to each insertion
4. computeDisfluencyStats(taggedAlignment):
   - total, contentWords, rate, byType counts
   - CRITICAL: rate = disfluencies / contentWords (NOT total words) per DISF-07

**Exports:** `tagDisfluencies`, `computeDisfluencyStats`, `FILLER_WORDS` (for potential reuse)

**Use the complete code examples from 21-RESEARCH.md Patterns 2 and 3** as starting point.

**Do NOT:**
- Count disfluencies as errors (per clinical ORF standards)
- Include disfluencies in denominator for rate calculation
- Duplicate the DISFLUENCIES Set - either import from text-normalize.js or create expanded version here
  </action>
  <verify>
Create inline tests (commented out) that verify:
```javascript
// Test fillers
classifyDisfluency({verbatim: 'um', type: 'insertion'}, [], 0) === 'filler'

// Test repetitions - "the the" where second "the" is insertion
const alignment = [
  {verbatim: 'the', clean: 'the', type: 'match'},
  {verbatim: 'the', clean: null, type: 'insertion'},
  {verbatim: 'cat', clean: 'cat', type: 'match'}
];
tagDisfluencies(alignment)[1].disfluencyType === 'repetition'

// Test stats - rate excludes disfluencies from denominator
// 1 disfluency, 2 content words -> rate = 50% (not 33%)
```
Run: `node --experimental-vm-modules -e "import('./js/disfluency-tagger.js')"` should not throw.
  </verify>
  <done>
- disfluency-tagger.js exists with tagDisfluencies, computeDisfluencyStats exports
- Fillers (um, uh, er, ah, mm, hmm) classified as 'filler'
- Repetitions detected by adjacent word matching
- False starts detected by prefix matching
- Disfluency rate calculation uses contentWords as denominator (WCPM integrity preserved)
  </done>
</task>

</tasks>

<verification>
Phase 21 success criteria verification:

1. "the the cat" vs "the cat" alignment produces exactly one insertion at index 1
   - Run alignTranscripts test case

2. Filler words (um, uh, er, ah, mm, hmm) are classified as type "filler"
   - Test tagDisfluencies with filler insertions

3. Consecutive repeated words are classified as type "repetition"
   - Test "the the" pattern

4. Partial words followed by complete word are classified as type "false_start"
   - Test "p" followed by "please" pattern

5. Disfluency rate calculation excludes disfluencies from denominator
   - Test computeDisfluencyStats: 1 disfluency + 2 content words = 50% rate (not 33%)

All requirements covered:
- DISF-01: NW alignment (Task 1)
- DISF-02: Insertions = disfluencies (Task 1)
- DISF-03: Fillers (Task 2)
- DISF-04: Repetitions (Task 2)
- DISF-05: False starts (Task 2)
- DISF-06: Rate calculation (Task 2)
- DISF-07: WCPM intact (Task 2)
- INTG-03: sequence-aligner.js (Task 1)
- INTG-04: disfluency-tagger.js (Task 2)
</verification>

<success_criteria>
- [ ] js/sequence-aligner.js exists and exports alignTranscripts
- [ ] js/disfluency-tagger.js exists and exports tagDisfluencies, computeDisfluencyStats
- [ ] "the the cat" vs "the cat" produces one insertion
- [ ] Fillers classified correctly
- [ ] Repetitions classified correctly
- [ ] False starts classified correctly
- [ ] Rate calculation preserves WCPM integrity (denominator = content words only)
- [ ] Both files import cleanly without errors
- [ ] Code follows existing codebase JSDoc and export patterns
</success_criteria>

<output>
After completion, create `.planning/phases/21-sequence-alignment-disfluency/21-01-SUMMARY.md`
</output>
