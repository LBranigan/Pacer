---
phase: 24-disfluency-ui-display
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - js/ui.js
  - js/app.js
  - index.html
autonomous: false

must_haves:
  truths:
    - "Disfluent words show a small dot above them in the alignment results"
    - "Hovering on a disfluent word shows tooltip with type and 'not an error' note"
    - "Diagnostics panel shows collapsible Disfluencies section with count and breakdown"
    - "Disfluent words do NOT appear in the Inserted words section"
    - "WCPM display is unchanged (disfluencies not counted as errors)"
  artifacts:
    - path: "js/ui.js"
      provides: "Disfluency dot marker rendering, tooltip, diagnostics section population"
      contains: "word-disfluency"
    - path: "js/app.js"
      provides: "Kitchen Sink disfluencyStats threaded to UI display function"
      contains: "disfluencyStats"
    - path: "index.html"
      provides: "Updated version timestamp"
      contains: "v 2026-"
  key_links:
    - from: "js/app.js"
      to: "js/ui.js"
      via: "displayAlignmentResults parameter for disfluencyStats"
      pattern: "kitchenSinkResult\\.disfluencyStats"
    - from: "js/ui.js"
      to: "index.html"
      via: "getElementById disfluencySection population"
      pattern: "disfluencySection"
    - from: "js/ui.js"
      to: "style.css"
      via: "classList.add word-disfluency"
      pattern: "word-disfluency"
---

<objective>
Wire up the JavaScript logic for disfluency display: dot markers on words, tooltips, diagnostics section population, data threading from app.js, and insertion filtering.

Purpose: Completes the Disfluency UI Display phase by connecting the Kitchen Sink pipeline data (isDisfluency, disfluencyType, disfluencyStats) to the visual elements created in Plan 01. After this plan, teachers can see disfluencies marked with dots, get type details on hover, and view summary statistics.

Output: Working disfluency visualization in ui.js, data threading in app.js, version update in index.html.
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-disfluency-ui-display/24-CONTEXT.md
@.planning/phases/24-disfluency-ui-display/24-RESEARCH.md
@.planning/phases/24-disfluency-ui-display/24-01-SUMMARY.md
@js/ui.js
@js/app.js
@js/kitchen-sink-merger.js
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add disfluency rendering logic to ui.js and thread data from app.js</name>
  <files>js/ui.js, js/app.js, index.html</files>
  <action>
This task makes 4 changes across 3 files. Work through them in order.

**Change 1: Thread disfluencyStats from app.js to ui.js**

In `js/app.js`, around line 316 where the `data` object is constructed, store `kitchenSinkResult.disfluencyStats` on the data object. Add to the data object:
```javascript
_kitchenSink: {
  disfluencyStats: kitchenSinkResult.disfluencyStats || null
},
```

Then around line 890-900 where `displayAlignmentResults` is called, change the 8th parameter (disfluencySummary) to pass Kitchen Sink disfluencyStats when available, falling back to old Phase 14 summary:

```javascript
// Prefer Kitchen Sink disfluencyStats (Phase 24) over Phase 14 severity summary
data._kitchenSink?.disfluencyStats || data._disfluency?.summary || null,
```

IMPORTANT: `kitchenSinkResult` is only in scope inside the `else` block (short recordings path, around line 152-345). The `_kitchenSink` property must be set inside that block on the `data` object, same as `_disfluency`, `_safety`, etc. The variable `kitchenSinkResult` does NOT exist in the long recording (async) path -- that's fine because Kitchen Sink only runs for short recordings.

**Change 2: Disfluency dot marker and tooltip in ui.js word rendering loop**

In `js/ui.js`, in the word rendering loop inside `displayAlignmentResults` (around line 427-595), add disfluency detection AFTER the struggle word overlay (line ~546) and BEFORE the pause indicator section (line ~548). This places it in the right spot in the rendering flow where `sttWord` is available.

Add this block:
```javascript
// Kitchen Sink disfluency dot marker (Phase 24)
// sttWord has isDisfluency and disfluencyType from kitchen-sink-merger.js
if (sttWord?.isDisfluency) {
  span.classList.add('word-disfluency');
  const typeLabels = {
    filler: 'Filler (um, uh)',
    repetition: 'Repetition',
    false_start: 'False start',
    unknown: 'Disfluency'
  };
  const label = typeLabels[sttWord.disfluencyType] || 'Disfluency';
  span.title += '\n' + label + ' â€” not an error';
}
```

CRITICAL: This must interact correctly with the existing Phase 16 disfluency badge code (lines 573-588). The Phase 16 badge checks `sttWord?.severity && sttWord.severity !== 'none'` which is the OLD severity-based system. Kitchen Sink words do NOT have a `severity` property -- they have `isDisfluency` and `disfluencyType` instead. So both systems can coexist: Phase 16 badges show for old-style severity data, Phase 24 dots show for Kitchen Sink isDisfluency data. No conflict.

However, when Kitchen Sink data IS present (sttWord.isDisfluency exists as a property), SKIP the Phase 16 badge to avoid double-marking. Update the Phase 16 badge check (around line 573-574) to:
```javascript
// Check for disfluency badge (Phase 16) -- skip when Kitchen Sink data present
const hasDisfluency = sttWord?.severity && sttWord.severity !== 'none' && !('isDisfluency' in (sttWord || {}));
```

**Change 3: Filter disfluent words from insertions display**

In `js/ui.js`, around line 598 where insertions are filtered, update the filter to also exclude disfluent words. Disfluent words (fillers like "um") should NOT appear in the "Inserted words" section since they are expected disfluencies, not unexpected extra words.

Change:
```javascript
const regularInsertions = insertions.filter(ins => !ins.partOfForgiven);
```
To:
```javascript
// Filter out forgiven proper noun parts AND disfluent words (fillers, repetitions)
// Disfluent words are expected speech patterns, not unexpected insertions
const regularInsertions = insertions.filter(ins => {
  if (ins.partOfForgiven) return false;
  // Check if the corresponding STT word is a disfluency
  if (ins.hyp && sttLookup) {
    const queue = sttLookup.get(ins.hyp);
    // Peek at first item without consuming it
    if (queue && queue.length > 0 && queue[0]?.isDisfluency) return false;
  }
  return true;
});
```

NOTE: Be careful with the sttLookup queue -- use peek (check queue[0]) not shift() here because the insertion rendering loop below will shift() when building tooltips. If you shift() here, the tooltip code won't find the word.

**Change 4: Render disfluency diagnostics section**

In `js/ui.js`, add a new function `renderDisfluencySection` after the existing `displayAlignmentResults` function (or at the end of the file before exports). This function populates the HTML section from Plan 01.

```javascript
/**
 * Render the disfluency diagnostics section (Phase 24).
 * Populates the collapsible section with count, rate, and type breakdown.
 *
 * @param {object|null} disfluencyStats - Stats from Kitchen Sink pipeline:
 *   { total, contentWords, rate, byType: { filler, repetition, false_start, unknown } }
 */
function renderDisfluencySection(disfluencyStats) {
  const section = document.getElementById('disfluencySection');
  const summaryEl = document.getElementById('disfluencySummaryText');
  const detailsEl = document.getElementById('disfluencyDetails');

  if (!section || !summaryEl || !detailsEl) return;

  // Hide section if no disfluency data or zero disfluencies
  if (!disfluencyStats || disfluencyStats.total === 0) {
    section.style.display = 'none';
    return;
  }

  // Show section
  section.style.display = '';

  // Determine dominant type for collapsed summary
  const byType = disfluencyStats.byType || {};
  let dominant = '';
  let maxCount = 0;
  for (const [type, count] of Object.entries(byType)) {
    if (count > maxCount) {
      maxCount = count;
      dominant = type;
    }
  }

  const dominantLabels = {
    filler: 'fillers',
    repetition: 'repetitions',
    false_start: 'false starts',
    unknown: 'unclassified'
  };
  const dominantText = dominant && maxCount > 0
    ? ` (mostly ${dominantLabels[dominant] || dominant})`
    : '';

  // Collapsed summary line
  summaryEl.textContent = `Disfluencies: ${disfluencyStats.total}${dominantText}`;

  // Expanded detail breakdown
  detailsEl.innerHTML = '';

  const typeDisplay = [
    { key: 'filler', label: 'Fillers (um, uh)' },
    { key: 'repetition', label: 'Repetitions' },
    { key: 'false_start', label: 'False starts' },
    { key: 'unknown', label: 'Other' }
  ];

  for (const { key, label } of typeDisplay) {
    const count = byType[key] || 0;
    if (count === 0) continue;

    const row = document.createElement('div');
    row.className = 'disfluency-type-row';

    const labelSpan = document.createElement('span');
    labelSpan.className = 'disfluency-type-label';
    labelSpan.textContent = label;

    const countSpan = document.createElement('span');
    countSpan.className = 'disfluency-type-count';
    countSpan.textContent = count;

    row.appendChild(labelSpan);
    row.appendChild(countSpan);
    detailsEl.appendChild(row);
  }

  // Rate line at bottom
  if (disfluencyStats.rate) {
    const rateLine = document.createElement('div');
    rateLine.style.marginTop = '0.5rem';
    rateLine.style.color = '#888';
    rateLine.style.fontSize = '0.8rem';
    rateLine.textContent = `Rate: ${disfluencyStats.rate} of words`;
    detailsEl.appendChild(rateLine);
  }
}
```

Call `renderDisfluencySection` at the end of `displayAlignmentResults`, after the confidence visualization section is rendered (around line 730-ish, near the end of the function). Pass the `disfluencySummary` parameter which now carries `disfluencyStats`:

```javascript
// Disfluency diagnostics section (Phase 24)
// disfluencySummary carries Kitchen Sink disfluencyStats when available
if (disfluencySummary && disfluencySummary.total !== undefined) {
  renderDisfluencySection(disfluencySummary);
}
```

The condition `disfluencySummary.total !== undefined` distinguishes Kitchen Sink stats (has `.total`) from old Phase 14 summary (has `.totalWordsWithDisfluency`). Only render the new section for Kitchen Sink data.

**Change 5: Update version timestamp**

In `index.html`, update the version div (line 18) to current date/time.

  </action>
  <verify>
1. `grep -n 'isDisfluency' js/ui.js` shows the dot marker code in word rendering loop
2. `grep -n '_kitchenSink' js/app.js` shows disfluencyStats stored on data object
3. `grep -n 'renderDisfluencySection' js/ui.js` shows the diagnostics rendering function
4. `grep -n 'partOfForgiven' js/ui.js` shows the updated insertion filter that also checks isDisfluency
5. Check that the Phase 16 badge check now includes `!('isDisfluency' in ...)` guard
6. Version timestamp is updated in index.html
  </verify>
  <done>
- Disfluent words get .word-disfluency class (dot marker) and tooltip with type + "not an error"
- Disfluency diagnostics section populates with count, dominant type summary, and per-type breakdown
- Disfluent words filtered from Inserted words section
- Phase 16 severity badges skipped when Kitchen Sink data present
- disfluencyStats threaded from app.js through to ui.js
- Version timestamp updated
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete disfluency UI display: dot markers above disfluent words, hover tooltips showing type ("Filler (um, uh) -- not an error"), collapsible Disfluencies diagnostics section with count and breakdown, disfluent words filtered from insertions display.</what-built>
  <how-to-verify>
1. Start the Reverb service and open the app in browser
2. Record or upload audio that contains fillers (say "um" or "uh" between words)
3. After analysis completes, check the alignment results:
   a. Disfluent words should have a small gray dot above them
   b. Hover over a disfluent word -- tooltip should show type (e.g., "Filler (um, uh) -- not an error")
   c. Disfluent words should NOT appear in the "Inserted words" section
4. Check the diagnostics area (below Confidence View):
   a. "Disfluencies" collapsible section should appear
   b. Collapsed: shows count + dominant type (e.g., "Disfluencies: 2 (mostly fillers)")
   c. Click to expand: shows breakdown by type (Fillers: 2, Repetitions: 0, etc.)
5. Verify WCPM is unchanged -- disfluencies should not affect the word count or accuracy
6. If Reverb is offline, verify the disfluency section does NOT appear (graceful degradation)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Disfluent words display gray dot above them (CSS ::before pseudo-element)
2. Hover tooltip shows disfluency type + "not an error"
3. Disfluency section visible in diagnostics with correct counts
4. Disfluent words NOT in insertions section
5. WCPM unchanged (disfluencies do not count as errors)
6. No errors in browser console related to disfluency rendering
7. Graceful degradation when Reverb offline (no disfluency section shown)
</verification>

<success_criteria>
- UI-01: Disfluency words have distinct styling (gray dot, not red/green) -- VERIFIED
- UI-02: Per-word type indicator via dot marker class -- VERIFIED
- UI-03: Tooltip shows type + "not an error" on hover -- VERIFIED
- UI-04: Diagnostics panel shows count, rate, breakdown in collapsible section -- VERIFIED
- UI-05: miscue-registry.js updated (completed in Plan 01) -- VERIFIED
- WCPM display unchanged (DISF-07 preserved) -- VERIFIED
</success_criteria>

<output>
After completion, create `.planning/phases/24-disfluency-ui-display/24-02-SUMMARY.md`
</output>
