---
phase: 14-disfluency-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/disfluency-config.js
  - js/disfluency-detector.js
autonomous: true

must_haves:
  truths:
    - "Stutter attempts are counted for each word (includes full word repetitions)"
    - "Total duration is computed from first fragment startTime to target word endTime"
    - "Max pause is the longest gap between consecutive attempts"
    - "Fragments within 2s gap of each other are grouped as same stutter event"
  artifacts:
    - path: "js/disfluency-config.js"
      provides: "Disfluency thresholds and constants"
      exports: ["DISFLUENCY_THRESHOLDS", "SEVERITY_LEVELS"]
    - path: "js/disfluency-detector.js"
      provides: "Core metrics computation functions"
      exports: ["computeDisfluencyMetrics", "groupStutterEvents"]
  key_links:
    - from: "js/disfluency-detector.js"
      to: "js/disfluency-config.js"
      via: "import thresholds"
      pattern: "import.*DISFLUENCY_THRESHOLDS"
    - from: "js/disfluency-detector.js"
      to: "js/diagnostics.js"
      via: "import parseTime"
      pattern: "import.*parseTime"
---

<objective>
Create disfluency detection module with stutter metrics calculation functions.

Purpose: Compute attempt count, total duration, and max pause for stutter events. These metrics are the foundation for severity classification (Plan 02) and fragment merging (Plan 03). Stutter events are grouped by temporal proximity (2s max gap), not text matching.
Output: js/disfluency-config.js (constants), js/disfluency-detector.js (metrics functions)
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-disfluency-detection/14-CONTEXT.md
@.planning/phases/14-disfluency-detection/14-RESEARCH.md

@js/diagnostics.js
@js/confidence-classifier.js
@js/ensemble-merger.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create disfluency configuration module</name>
  <files>js/disfluency-config.js</files>
  <action>
Create new file js/disfluency-config.js with thresholds and constants:

```javascript
/**
 * Disfluency detection configuration.
 * Per CONTEXT.md: thresholds are configurable in dev mode.
 */

// Severity thresholds (per CONTEXT.md "Count-First, Duration-Override" model)
export const DISFLUENCY_THRESHOLDS = {
  // Gap threshold for grouping stutter attempts
  MAX_STUTTER_GAP_SEC: 2.0,

  // Duration override thresholds
  SIGNIFICANT_DURATION_SEC: 2.0,  // totalDuration >= 2.0s -> significant
  MODERATE_PAUSE_SEC: 0.5,        // maxPause >= 0.5s with 2+ attempts -> moderate

  // Attempt count thresholds
  SIGNIFICANT_ATTEMPTS: 5,  // 5+ attempts -> significant
  MODERATE_ATTEMPTS: 3,     // 3-4 attempts -> moderate
  MINOR_ATTEMPTS: 2,        // 2 attempts -> minor

  // Fragment merge eligibility
  SHORT_FRAGMENT_MAX_CHARS: 3,  // Fragments <= 3 chars use prefix matching
  LONG_PREFIX_MIN_CHARS: 4      // Fragments >= 4 chars need exact or long prefix match
};

// Severity levels
export const SEVERITY_LEVELS = {
  NONE: 'none',
  MINOR: 'minor',
  MODERATE: 'moderate',
  SIGNIFICANT: 'significant'
};

// Export for dev mode slider
export const THRESHOLD_RANGES = {
  MAX_STUTTER_GAP_SEC: { min: 0.5, max: 5.0, step: 0.5 },
  SIGNIFICANT_DURATION_SEC: { min: 1.0, max: 5.0, step: 0.5 },
  MODERATE_PAUSE_SEC: { min: 0.2, max: 1.0, step: 0.1 }
};
```

This establishes all configurable thresholds in one place.
  </action>
  <verify>
Browser console test:
```javascript
import { DISFLUENCY_THRESHOLDS, SEVERITY_LEVELS } from './js/disfluency-config.js';
console.assert(DISFLUENCY_THRESHOLDS.MAX_STUTTER_GAP_SEC === 2.0, 'Gap threshold');
console.assert(DISFLUENCY_THRESHOLDS.SIGNIFICANT_ATTEMPTS === 5, 'Significant attempts');
console.assert(SEVERITY_LEVELS.SIGNIFICANT === 'significant', 'Severity level');
console.log('disfluency-config tests passed');
```
  </verify>
  <done>
- DISFLUENCY_THRESHOLDS exported with all timing/count thresholds
- SEVERITY_LEVELS exported for consistent string values
- THRESHOLD_RANGES exported for future dev mode slider
- All values match CONTEXT.md decisions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create stutter event grouping function</name>
  <files>js/disfluency-detector.js</files>
  <action>
Create new file js/disfluency-detector.js with temporal grouping logic:

```javascript
/**
 * Disfluency detector - stutter metrics and fragment merging.
 * Detects stutters as a SEPARATE signal from confidence.
 *
 * Pipeline order: Classify -> Filter ghosts -> Detect disfluencies -> Align
 */

import { parseTime } from './diagnostics.js';
import { DISFLUENCY_THRESHOLDS, SEVERITY_LEVELS } from './disfluency-config.js';

/**
 * Group consecutive words within MAX_STUTTER_GAP_SEC into potential stutter events.
 * Words are grouped by temporal proximity, not text content.
 *
 * @param {Array} words - Array of word objects with startTime/endTime
 * @returns {Array<Array>} Array of word groups (each group is potential stutter event)
 */
export function groupStutterEvents(words) {
  if (!words || words.length === 0) return [];

  const groups = [];
  let currentGroup = [words[0]];

  for (let i = 1; i < words.length; i++) {
    const prevEnd = parseTime(words[i - 1].endTime);
    const currStart = parseTime(words[i].startTime);
    const gap = currStart - prevEnd;

    if (gap <= DISFLUENCY_THRESHOLDS.MAX_STUTTER_GAP_SEC && gap >= 0) {
      // Within gap threshold - add to current group
      currentGroup.push(words[i]);
    } else {
      // Gap too large - start new group
      groups.push(currentGroup);
      currentGroup = [words[i]];
    }
  }

  // Don't forget the last group
  groups.push(currentGroup);

  return groups;
}

/**
 * Compute pause durations between consecutive words in a group.
 *
 * @param {Array} words - Array of words in chronological order
 * @returns {Array<number>} Array of pause durations in seconds
 */
function computePauses(words) {
  const pauses = [];
  for (let i = 1; i < words.length; i++) {
    const prevEnd = parseTime(words[i - 1].endTime);
    const currStart = parseTime(words[i].startTime);
    const pause = Math.max(0, currStart - prevEnd);
    pauses.push(pause);
  }
  return pauses;
}

/**
 * Compute disfluency metrics for a group of words.
 * Used to calculate attempt count, total duration, and max pause.
 *
 * @param {Array} attemptWords - Words that are part of same stutter event
 * @returns {object|null} { attempts, totalDuration, maxPause } or null if only 1 word
 */
export function computeDisfluencyMetrics(attemptWords) {
  if (!attemptWords || attemptWords.length <= 1) {
    return null;
  }

  // Sort by start time (should already be sorted, but be safe)
  const sorted = [...attemptWords].sort(
    (a, b) => parseTime(a.startTime) - parseTime(b.startTime)
  );

  const pauses = computePauses(sorted);
  const firstStart = parseTime(sorted[0].startTime);
  const lastEnd = parseTime(sorted[sorted.length - 1].endTime);

  return {
    attempts: sorted.length,
    totalDuration: Math.round((lastEnd - firstStart) * 100) / 100,
    maxPause: pauses.length > 0 ? Math.round(Math.max(...pauses) * 100) / 100 : 0
  };
}
```

Key decisions:
- Uses parseTime from diagnostics.js (reuse existing utility)
- Groups are formed by temporal proximity only
- Single-word groups return null (no disfluency)
- Metrics rounded to 2 decimal places for readability
  </action>
  <verify>
Browser console tests:
```javascript
import { groupStutterEvents, computeDisfluencyMetrics } from './js/disfluency-detector.js';

// Test grouping with 2s gap threshold
const words = [
  { word: 'p', startTime: '0.0s', endTime: '0.2s' },
  { word: 'p', startTime: '0.5s', endTime: '0.7s' },
  { word: 'please', startTime: '1.2s', endTime: '1.8s' },
  { word: 'help', startTime: '5.0s', endTime: '5.4s' }  // >2s gap
];

const groups = groupStutterEvents(words);
console.assert(groups.length === 2, 'Two groups (2s gap splits)');
console.assert(groups[0].length === 3, 'First group has 3 words');
console.assert(groups[1].length === 1, 'Second group has 1 word');

// Test metrics computation
const metrics = computeDisfluencyMetrics(groups[0]);
console.assert(metrics.attempts === 3, 'Attempts: 3');
console.assert(metrics.totalDuration === 1.8, 'Duration: 1.8s');
console.assert(metrics.maxPause === 0.5, 'MaxPause: 0.5s');

// Test single word returns null
const singleMetrics = computeDisfluencyMetrics(groups[1]);
console.assert(singleMetrics === null, 'Single word: null');

console.log('groupStutterEvents and computeDisfluencyMetrics tests passed');
```
  </verify>
  <done>
- groupStutterEvents() groups words by 2s temporal proximity
- computePauses() calculates gaps between consecutive words
- computeDisfluencyMetrics() returns { attempts, totalDuration, maxPause }
- Single-word groups return null (no stutter event)
- Metrics rounded to 2 decimal places
- Uses parseTime from diagnostics.js
  </done>
</task>

</tasks>

<verification>
1. js/disfluency-config.js loads without errors
2. js/disfluency-detector.js loads without errors
3. groupStutterEvents() groups by 2s gap correctly
4. computeDisfluencyMetrics() computes attempts/duration/maxPause
5. Single-word groups return null
6. Existing app functionality unaffected (module not yet integrated)
</verification>

<success_criteria>
- Config module exports all thresholds from CONTEXT.md
- Stutter events grouped by 2s temporal proximity
- Metrics computation handles edge cases (empty, single word)
- parseTime reused from diagnostics.js (no hand-rolling)
- All functions exported and testable independently
</success_criteria>

<output>
After completion, create `.planning/phases/14-disfluency-detection/14-01-SUMMARY.md`
</output>
