---
phase: 14-disfluency-detection
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - js/disfluency-detector.js
autonomous: true

must_haves:
  truths:
    - "Severity 'none' for 1 attempt (clean read)"
    - "Severity 'minor' for 2 attempts"
    - "Severity 'moderate' for 3-4 attempts OR (maxPause >= 0.5s AND attempts >= 2)"
    - "Severity 'significant' for 5+ attempts OR totalDuration >= 2.0s"
    - "Every word gets scored (including clean words with severity:'none')"
  artifacts:
    - path: "js/disfluency-detector.js"
      provides: "Severity classification function"
      exports: ["calculateSeverity", "computeDisfluencyMetrics", "groupStutterEvents"]
  key_links:
    - from: "js/disfluency-detector.js:calculateSeverity"
      to: "js/disfluency-config.js"
      via: "import severity thresholds"
      pattern: "DISFLUENCY_THRESHOLDS\\.(SIGNIFICANT|MODERATE)"
---

<objective>
Add disfluency severity classification using the "Count-First, Duration-Override" model.

Purpose: Classify each word's disfluency severity based on stutter metrics. The model prioritizes attempt count but allows duration/pause to escalate severity. This enables teachers to quickly identify which words caused the most struggle.
Output: calculateSeverity() function added to js/disfluency-detector.js
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-disfluency-detection/14-CONTEXT.md
@.planning/phases/14-disfluency-detection/14-RESEARCH.md
@.planning/phases/14-disfluency-detection/14-01-SUMMARY.md

@js/disfluency-config.js
@js/disfluency-detector.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add severity classification function</name>
  <files>js/disfluency-detector.js</files>
  <action>
Add calculateSeverity() function to js/disfluency-detector.js after computeDisfluencyMetrics():

```javascript
/**
 * Calculate disfluency severity using "Count-First, Duration-Override" model.
 * Per CONTEXT.md algorithm:
 *   - 5+ attempts OR totalDuration >= 2.0s -> significant
 *   - maxPause >= 0.5s AND attempts >= 2 -> moderate (duration override)
 *   - 3-4 attempts -> moderate
 *   - 2 attempts -> minor
 *   - 1 attempt -> none (clean read)
 *
 * @param {number} attempts - Number of stutter attempts (1 = clean read)
 * @param {number} totalDuration - Total time from first attempt to word end (seconds)
 * @param {number} maxPause - Longest pause between attempts (seconds)
 * @returns {string} Severity level: 'none' | 'minor' | 'moderate' | 'significant'
 */
export function calculateSeverity(attempts, totalDuration = 0, maxPause = 0) {
  // Default to 'none' for clean reads
  if (attempts <= 1) return SEVERITY_LEVELS.NONE;

  // Check significant thresholds first (highest priority)
  if (attempts >= DISFLUENCY_THRESHOLDS.SIGNIFICANT_ATTEMPTS ||
      totalDuration >= DISFLUENCY_THRESHOLDS.SIGNIFICANT_DURATION_SEC) {
    return SEVERITY_LEVELS.SIGNIFICANT;
  }

  // Duration override: long pause with multiple attempts escalates to moderate
  if (maxPause >= DISFLUENCY_THRESHOLDS.MODERATE_PAUSE_SEC && attempts >= 2) {
    return SEVERITY_LEVELS.MODERATE;
  }

  // Moderate by attempt count
  if (attempts >= DISFLUENCY_THRESHOLDS.MODERATE_ATTEMPTS) {
    return SEVERITY_LEVELS.MODERATE;
  }

  // Minor: exactly 2 attempts ("the double take")
  if (attempts === DISFLUENCY_THRESHOLDS.MINOR_ATTEMPTS) {
    return SEVERITY_LEVELS.MINOR;
  }

  // Fallback (should not reach here, but be safe)
  return SEVERITY_LEVELS.NONE;
}
```

The order of checks matters:
1. First check significant (highest severity)
2. Then duration override for moderate
3. Then count-based moderate
4. Then minor
5. Fallback to none
  </action>
  <verify>
Browser console tests:
```javascript
import { calculateSeverity } from './js/disfluency-detector.js';

// Test: 1 attempt = none (clean read)
console.assert(calculateSeverity(1) === 'none', '1 attempt: none');

// Test: 2 attempts = minor ("the double take")
console.assert(calculateSeverity(2) === 'minor', '2 attempts: minor');

// Test: 3 attempts = moderate
console.assert(calculateSeverity(3) === 'moderate', '3 attempts: moderate');

// Test: 4 attempts = moderate
console.assert(calculateSeverity(4) === 'moderate', '4 attempts: moderate');

// Test: 5 attempts = significant
console.assert(calculateSeverity(5) === 'significant', '5 attempts: significant');

// Test: 10 attempts = significant
console.assert(calculateSeverity(10) === 'significant', '10 attempts: significant');

// Test: Duration override - 2.0s total = significant regardless of attempts
console.assert(calculateSeverity(2, 2.0, 0.3) === 'significant', '2.0s duration: significant');

// Test: Duration override - long pause with 2+ attempts = moderate
console.assert(calculateSeverity(2, 1.0, 0.5) === 'moderate', '0.5s pause + 2 attempts: moderate');

// Test: Long pause with 1 attempt stays none (needs 2+ attempts)
console.assert(calculateSeverity(1, 1.0, 0.5) === 'none', '1 attempt + pause: none');

console.log('calculateSeverity tests passed');
```
  </verify>
  <done>
- calculateSeverity() implements full "Count-First, Duration-Override" model
- 1 attempt = 'none' (clean read)
- 2 attempts = 'minor' (the double take)
- 3-4 attempts = 'moderate' (the struggle)
- 5+ attempts = 'significant' (the block/loop)
- totalDuration >= 2.0s = 'significant' (duration override)
- maxPause >= 0.5s with 2+ attempts = 'moderate' (pause override)
- Check order enforces highest severity wins
  </done>
</task>

<task type="auto">
  <name>Task 2: Add merge eligibility check function</name>
  <files>js/disfluency-detector.js</files>
  <action>
Add isMergeEligible() function to js/disfluency-detector.js for use in fragment merging (Plan 03):

```javascript
/**
 * Check if a fragment word should be merged into a target word.
 * Per CONTEXT.md merge eligibility rules:
 *   - First char must match
 *   - Short fragments (1-3 chars): must match prefix of target
 *   - Long fragments (4+ chars): must be exact match OR long prefix match
 *
 * This distinguishes stutters from substitutions:
 *   - "p" before "please" -> stutter (merge)
 *   - "beauti" before "beautiful" -> stutter (merge, long prefix)
 *   - "sat" before "sit" -> substitution (no merge, 3+ chars, not exact)
 *
 * @param {string} fragment - The potential fragment word
 * @param {string} target - The potential target word
 * @returns {boolean} True if fragment should merge into target
 */
export function isMergeEligible(fragment, target) {
  if (!fragment || !target) return false;

  const f = fragment.toLowerCase();
  const t = target.toLowerCase();

  // First char must match
  if (!t.startsWith(f.charAt(0))) return false;

  // Short fragments (1-3 chars): must match prefix of target
  if (f.length <= DISFLUENCY_THRESHOLDS.SHORT_FRAGMENT_MAX_CHARS) {
    return t.startsWith(f);
  }

  // Long fragments (4+ chars): must be exact match OR long prefix match
  // Exact match handles full word repetitions: "ball" before "ball"
  // Long prefix handles partial: "beauti" before "beautiful"
  return (f === t) || (t.startsWith(f) && f.length >= DISFLUENCY_THRESHOLDS.LONG_PREFIX_MIN_CHARS);
}
```

Key distinction from substitutions:
- "sat" before "sit": f.length=3, uses prefix rule, "sit".startsWith("sat") = false -> NOT merge eligible (correct: it's a substitution)
- "s" before "sit": f.length=1, uses prefix rule, "sit".startsWith("s") = true -> merge eligible
  </action>
  <verify>
Browser console tests:
```javascript
import { isMergeEligible } from './js/disfluency-detector.js';

// Short fragments (1-3 chars) - prefix matching
console.assert(isMergeEligible('p', 'please') === true, 'p -> please: true');
console.assert(isMergeEligible('pl', 'please') === true, 'pl -> please: true');
console.assert(isMergeEligible('ple', 'please') === true, 'ple -> please: true');

// Short fragment, wrong first char
console.assert(isMergeEligible('b', 'please') === false, 'b -> please: false');

// Substitution detection - 3 chars, doesn't match prefix
console.assert(isMergeEligible('sat', 'sit') === false, 'sat -> sit: false (substitution)');
console.assert(isMergeEligible('the', 'they') === true, 'the -> they: true (prefix)');

// Long fragments (4+ chars) - exact or long prefix
console.assert(isMergeEligible('ball', 'ball') === true, 'ball -> ball: true (exact)');
console.assert(isMergeEligible('beauti', 'beautiful') === true, 'beauti -> beautiful: true (long prefix)');
console.assert(isMergeEligible('beau', 'beautiful') === true, 'beau -> beautiful: true (4-char prefix)');

// Long fragment, not matching
console.assert(isMergeEligible('balls', 'ball') === false, 'balls -> ball: false');
console.assert(isMergeEligible('beauty', 'beautiful') === false, 'beauty -> beautiful: false (not prefix)');

// Edge cases
console.assert(isMergeEligible('', 'word') === false, 'empty fragment: false');
console.assert(isMergeEligible('word', '') === false, 'empty target: false');

console.log('isMergeEligible tests passed');
```
  </verify>
  <done>
- isMergeEligible() distinguishes stutters from substitutions
- Short fragments (1-3 chars): prefix match required
- Long fragments (4+ chars): exact match OR long prefix match
- First character must always match
- "sat" before "sit" correctly identified as substitution (not stutter)
- Full word repetitions handled ("ball" -> "ball")
  </done>
</task>

</tasks>

<verification>
1. calculateSeverity() returns correct severity for all threshold combinations
2. Duration override works (2.0s -> significant)
3. Pause override works (0.5s + 2 attempts -> moderate)
4. isMergeEligible() correctly distinguishes stutters from substitutions
5. Existing tests from Plan 01 still pass
</verification>

<success_criteria>
- Severity classification matches CONTEXT.md algorithm exactly
- Check order ensures highest severity wins
- Substitutions not confused with stutters
- All edge cases handled (empty strings, single attempts)
- Functions exported and testable independently
</success_criteria>

<output>
After completion, create `.planning/phases/14-disfluency-detection/14-02-SUMMARY.md`
</output>
