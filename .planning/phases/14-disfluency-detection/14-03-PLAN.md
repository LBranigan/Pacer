---
phase: 14-disfluency-detection
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - js/disfluency-detector.js
  - js/app.js
  - index.html
autonomous: true

must_haves:
  truths:
    - "Orphaned stutter fragments are merged into their target word"
    - "Merged fragments are REMOVED from the main word array"
    - "Fragments appear in target word's _disfluency.fragments array"
    - "Nearest word (by time) wins when fragment could match multiple targets"
    - "Every word has attempts and severity properties (hoisted to root)"
    - "_disfluency object only present when attempts >= 2"
    - "Document-level _disfluencySummary shows counts by severity"
  artifacts:
    - path: "js/disfluency-detector.js"
      provides: "Full disfluency detection pipeline"
      exports: ["detectDisfluencies", "calculateSeverity", "isMergeEligible", "computeDisfluencyMetrics"]
    - path: "js/app.js"
      provides: "Disfluency detection integrated into assessment flow"
      contains: "detectDisfluencies"
  key_links:
    - from: "js/app.js"
      to: "js/disfluency-detector.js"
      via: "import detectDisfluencies"
      pattern: "import.*detectDisfluencies"
    - from: "js/disfluency-detector.js"
      to: "js/disfluency-config.js"
      via: "import thresholds"
      pattern: "import.*DISFLUENCY_THRESHOLDS"
---

<objective>
Complete disfluency detection with fragment merging and app integration.

Purpose: Merge orphaned stutter fragments into their target words and integrate disfluency detection into the assessment pipeline. After this plan, every word will have `attempts` and `severity` properties for UI display (Phase 16).
Output: detectDisfluencies() function, app.js integration, _disfluencySummary in saved assessments
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-disfluency-detection/14-CONTEXT.md
@.planning/phases/14-disfluency-detection/14-RESEARCH.md
@.planning/phases/14-disfluency-detection/14-01-SUMMARY.md
@.planning/phases/14-disfluency-detection/14-02-SUMMARY.md

@js/disfluency-config.js
@js/disfluency-detector.js
@js/app.js
@js/confidence-classifier.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fragment merging and main detection function</name>
  <files>js/disfluency-detector.js</files>
  <action>
Add detectDisfluencies() function to js/disfluency-detector.js that:
1. Scans for stutter patterns (fragments + repetitions)
2. Merges fragments into targets using "nearest word wins"
3. Computes metrics and severity for each word
4. Removes merged fragments from main array
5. Hoists attempts/severity to word root

```javascript
/**
 * Find the best target word for a fragment within a group.
 * Per CONTEXT.md: "Nearest word wins" - prefer closest by time.
 *
 * @param {object} fragment - The fragment word
 * @param {Array} candidates - Potential target words after the fragment
 * @returns {object|null} Best target word or null if no match
 */
function findBestTarget(fragment, candidates) {
  if (!candidates || candidates.length === 0) return null;

  // Candidates are already sorted by time (from the group)
  // Find first eligible target (nearest by time)
  for (const candidate of candidates) {
    if (isMergeEligible(fragment.word, candidate.word)) {
      return candidate;
    }
  }
  return null;
}

/**
 * Process a group of temporally-close words to detect stutters.
 * Identifies fragments, merges them into targets, computes metrics.
 *
 * @param {Array} group - Words within 2s gap of each other
 * @returns {object} { processedWords, fragmentsRemoved }
 */
function processStutterGroup(group) {
  if (group.length === 0) return { processedWords: [], fragmentsRemoved: 0 };
  if (group.length === 1) {
    // Single word - no stuttering, just add default disfluency props
    const word = { ...group[0], attempts: 1, severity: SEVERITY_LEVELS.NONE };
    return { processedWords: [word], fragmentsRemoved: 0 };
  }

  // Track which indices are fragments to be removed
  const fragmentIndices = new Set();
  // Map from target index to its fragments
  const targetFragments = new Map();

  // Forward scan: for each word, check if it's a fragment of a later word
  for (let i = 0; i < group.length - 1; i++) {
    if (fragmentIndices.has(i)) continue; // Already marked as fragment

    const current = group[i];
    const candidates = group.slice(i + 1);
    const target = findBestTarget(current, candidates);

    if (target) {
      const targetIdx = group.indexOf(target);

      // Current word is a fragment - mark for removal
      fragmentIndices.add(i);

      // Add to target's fragment list
      if (!targetFragments.has(targetIdx)) {
        targetFragments.set(targetIdx, []);
      }
      targetFragments.get(targetIdx).push({
        word: current.word,
        startTime: current.startTime,
        endTime: current.endTime
      });
    }
  }

  // Also check for full word repetitions (exact matches)
  // e.g., "ball ball ball" - all but last are fragments
  for (let i = 0; i < group.length - 1; i++) {
    if (fragmentIndices.has(i)) continue;

    const current = group[i];
    const currentLower = (current.word || '').toLowerCase();

    // Look for later exact match
    for (let j = i + 1; j < group.length; j++) {
      const candidate = group[j];
      if ((candidate.word || '').toLowerCase() === currentLower) {
        // This is a repetition - mark current as fragment of later occurrence
        fragmentIndices.add(i);
        if (!targetFragments.has(j)) {
          targetFragments.set(j, []);
        }
        targetFragments.get(j).push({
          word: current.word,
          startTime: current.startTime,
          endTime: current.endTime
        });
        break; // Move to next word
      }
    }
  }

  // Build processed words array (excluding fragments)
  const processedWords = [];
  for (let i = 0; i < group.length; i++) {
    if (fragmentIndices.has(i)) continue; // Skip fragments

    const word = { ...group[i] };
    const fragments = targetFragments.get(i) || [];

    // Compute metrics including fragments + this word
    const allAttempts = [...fragments, { word: word.word, startTime: word.startTime, endTime: word.endTime }];
    const attempts = allAttempts.length;

    if (attempts >= 2) {
      // Compute full metrics
      const metrics = computeDisfluencyMetrics(allAttempts.map((f, idx) => ({
        word: f.word,
        startTime: f.startTime,
        endTime: f.endTime
      })));

      word.attempts = attempts;
      word.severity = calculateSeverity(attempts, metrics?.totalDuration || 0, metrics?.maxPause || 0);
      word._disfluency = {
        maxPause: metrics?.maxPause || 0,
        totalDuration: metrics?.totalDuration || 0,
        fragments: fragments
      };
    } else {
      // Clean read
      word.attempts = 1;
      word.severity = SEVERITY_LEVELS.NONE;
      // No _disfluency object for clean reads
    }

    processedWords.push(word);
  }

  return {
    processedWords,
    fragmentsRemoved: fragmentIndices.size
  };
}

/**
 * Compute document-level disfluency summary.
 *
 * @param {Array} words - Processed words with severity
 * @returns {object} Summary counts by severity
 */
function computeDisfluencySummary(words) {
  const summary = {
    none: 0,
    minor: 0,
    moderate: 0,
    significant: 0,
    totalWordsWithDisfluency: 0
  };

  for (const word of words) {
    const sev = word.severity || SEVERITY_LEVELS.NONE;
    summary[sev] = (summary[sev] || 0) + 1;

    if (sev !== SEVERITY_LEVELS.NONE) {
      summary.totalWordsWithDisfluency++;
    }
  }

  return summary;
}

/**
 * Main disfluency detection function.
 * Processes words to detect stutters, merge fragments, and classify severity.
 *
 * Pipeline order: Call AFTER filterGhosts(), BEFORE alignment.
 *
 * @param {Array} words - Classified words (from filterGhosts output)
 * @returns {object} { words: processedWords, summary: _disfluencySummary, fragmentsRemoved }
 */
export function detectDisfluencies(words) {
  if (!words || words.length === 0) {
    return {
      words: [],
      summary: computeDisfluencySummary([]),
      fragmentsRemoved: 0
    };
  }

  // Step 1: Group words by temporal proximity
  const groups = groupStutterEvents(words);

  // Step 2: Process each group for stutters
  const allProcessed = [];
  let totalFragmentsRemoved = 0;

  for (const group of groups) {
    const { processedWords, fragmentsRemoved } = processStutterGroup(group);
    allProcessed.push(...processedWords);
    totalFragmentsRemoved += fragmentsRemoved;
  }

  // Step 3: Compute summary
  const summary = computeDisfluencySummary(allProcessed);

  return {
    words: allProcessed,
    summary: summary,
    fragmentsRemoved: totalFragmentsRemoved
  };
}
```

Key behaviors per CONTEXT.md:
- Fragments REMOVED from main array (only in target's _disfluency.fragments)
- Nearest word wins for fragment matching
- Full word repetitions count as stutter attempts
- attempts/severity hoisted to root for easy access
- _disfluency only present when attempts >= 2
  </action>
  <verify>
Browser console tests:
```javascript
import { detectDisfluencies } from './js/disfluency-detector.js';

// Test: stutter with fragments
const words1 = [
  { word: 'p', startTime: '0.0s', endTime: '0.2s' },
  { word: 'p', startTime: '0.5s', endTime: '0.7s' },
  { word: 'please', startTime: '1.2s', endTime: '1.8s' },
  { word: 'help', startTime: '2.5s', endTime: '3.0s' }
];

const result1 = detectDisfluencies(words1);
console.assert(result1.words.length === 2, 'Fragments removed: 2 words remain');
console.assert(result1.fragmentsRemoved === 2, 'fragmentsRemoved: 2');

const pleaseWord = result1.words.find(w => w.word === 'please');
console.assert(pleaseWord.attempts === 3, 'please: 3 attempts');
console.assert(pleaseWord.severity === 'moderate', 'please: moderate severity');
console.assert(pleaseWord._disfluency.fragments.length === 2, 'please: 2 fragments');

const helpWord = result1.words.find(w => w.word === 'help');
console.assert(helpWord.attempts === 1, 'help: 1 attempt (clean)');
console.assert(helpWord.severity === 'none', 'help: none severity');
console.assert(helpWord._disfluency === undefined, 'help: no _disfluency object');

// Test: full word repetition
const words2 = [
  { word: 'ball', startTime: '0.0s', endTime: '0.5s' },
  { word: 'ball', startTime: '0.8s', endTime: '1.3s' },
  { word: 'ball', startTime: '1.6s', endTime: '2.1s' }
];

const result2 = detectDisfluencies(words2);
console.assert(result2.words.length === 1, 'Repetitions merged: 1 word remains');
console.assert(result2.words[0].attempts === 3, 'ball: 3 attempts');
console.assert(result2.words[0].severity === 'moderate', 'ball: moderate');

// Test: summary
console.assert(result1.summary.moderate === 1, 'Summary: 1 moderate');
console.assert(result1.summary.none === 1, 'Summary: 1 none');
console.assert(result1.summary.totalWordsWithDisfluency === 1, 'Summary: 1 with disfluency');

console.log('detectDisfluencies tests passed');
```
  </verify>
  <done>
- detectDisfluencies() processes full word array
- Fragments merged into target words and REMOVED from main array
- Full word repetitions detected and merged
- "Nearest word wins" for fragment matching
- attempts/severity hoisted to word root
- _disfluency object only when attempts >= 2
- Document-level summary computed
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate into app.js assessment flow</name>
  <files>js/app.js</files>
  <action>
Add disfluency detection to app.js handleAnalyze flow:

1. Add import at top of file:
```javascript
import { detectDisfluencies } from './disfluency-detector.js';
```

2. Insert disfluency detection AFTER filterGhosts(), BEFORE constructing data object:

Find this section (around line 206):
```javascript
// Filter ghost words BEFORE alignment (confidence === 0.0)
const wordsForAlignment = filterGhosts(classifiedWords);
```

Add disfluency detection after it:
```javascript
// Filter ghost words BEFORE alignment (confidence === 0.0)
const wordsForAlignment = filterGhosts(classifiedWords);

// Disfluency detection (Phase 14)
// Pipeline: Classify -> Filter ghosts -> Detect disfluencies -> Align
setStatus('Detecting disfluencies...');
const disfluencyResult = detectDisfluencies(wordsForAlignment);
const wordsWithDisfluency = disfluencyResult.words;

addStage('disfluency_detection', {
  wordsProcessed: wordsForAlignment.length,
  wordsAfter: wordsWithDisfluency.length,
  fragmentsRemoved: disfluencyResult.fragmentsRemoved,
  summary: disfluencyResult.summary
});

if (disfluencyResult.fragmentsRemoved > 0) {
  console.log(`[ORF] Disfluency: ${disfluencyResult.fragmentsRemoved} fragments merged`);
}
if (disfluencyResult.summary.totalWordsWithDisfluency > 0) {
  console.log(`[ORF] Disfluency: ${disfluencyResult.summary.totalWordsWithDisfluency} words with stutter events`);
}
```

3. Update the data object to use wordsWithDisfluency and include _disfluencySummary:

Change (around line 219):
```javascript
data = {
  results: [{
    alternatives: [{
      words: wordsForAlignment,  // FILTERED words for alignment
      transcript: wordsForAlignment.map(w => w.word).join(' ')
    }]
  }],
```

To:
```javascript
data = {
  results: [{
    alternatives: [{
      words: wordsWithDisfluency,  // Words with disfluency data (fragments removed)
      transcript: wordsWithDisfluency.map(w => w.word).join(' ')
    }]
  }],
```

4. Add _disfluency to the data object (after _classification):
```javascript
_disfluency: {
  summary: disfluencyResult.summary,
  fragmentsRemoved: disfluencyResult.fragmentsRemoved
}
```

The complete data structure will be:
```javascript
data = {
  results: [{
    alternatives: [{
      words: wordsWithDisfluency,
      transcript: wordsWithDisfluency.map(w => w.word).join(' ')
    }]
  }],
  _ensemble: { raw, stats },
  _vad: { segments, durationMs, ghostCount, hasGhostSequence, error },
  _classification: { stats, allWords, filteredCount },
  _disfluency: { summary, fragmentsRemoved }
};
```
  </action>
  <verify>
1. Open browser dev tools, load app
2. Record a test phrase with stuttering (e.g., "p-p-please help me")
3. Check console for "[ORF] Disfluency:" log messages
4. In debug output, verify:
   - `disfluency_detection` stage shows fragmentsRemoved and summary
   - Words have `attempts` and `severity` properties
   - Fragments are NOT in main word array
   - `_disfluency` object present on stuttered words
  </verify>
  <done>
- Import added for detectDisfluencies
- Disfluency detection step added after filterGhosts
- Status message shown during detection
- Debug stage logs disfluency stats
- Console logs for fragments merged and words with disfluency
- wordsWithDisfluency used for alignment (fragments removed)
- _disfluency field added to data object for persistence
  </done>
</task>

<task type="auto">
  <name>Task 3: Update version and verify pipeline flow</name>
  <files>index.html</files>
  <action>
Update version timestamp in index.html to indicate Phase 14 integration.

Find the version element and update the timestamp to current time.

Pipeline after Phase 14:
```
Audio Recording
    |
Ensemble STT (latest_long + default)
    |
Merge Results (temporal word association)
    |
VAD Ghost Detection (flag vad_ghost_in_reference)
    |
Confidence Classification (trustLevel, _flags)
    |
Filter Ghosts (remove confidence 0.0)
    |
[NEW] Disfluency Detection
    |   - detectDisfluencies() finds stutters
    |   - Fragments merged into targets
    |   - attempts/severity added to each word
    |   - fragmentsRemoved count logged
    |
Alignment (receives processed words)
    |
WCPM Calculation
```
  </action>
  <verify>
1. Reload app in browser
2. Check version timestamp updated
3. Run full assessment with stuttering
4. Verify complete pipeline executes:
   - Ensemble STT runs
   - Ghost detection runs
   - Classification runs
   - Disfluency detection runs
   - Alignment runs
   - WCPM calculated correctly
  </verify>
  <done>
- Version timestamp updated
- Full pipeline verified end-to-end
- Phase 14 integration complete
  </done>
</task>

</tasks>

<verification>
1. detectDisfluencies() correctly merges fragments into targets
2. Fragments removed from main word array
3. Full word repetitions handled (e.g., "ball ball ball")
4. Every word has attempts and severity properties
5. _disfluency object only on words with attempts >= 2
6. _disfluencySummary computed correctly
7. App.js integration works end-to-end
8. Debug stages show disfluency data
9. Alignment receives processed words (fragments removed)
10. WCPM calculation unaffected (insertions still counted correctly)
</verification>

<success_criteria>
- Fragment merging removes orphaned stutters from main array
- Nearest word wins when multiple targets possible
- Every word has attempts (1 for clean) and severity (none for clean)
- _disfluency present only when meaningful (attempts >= 2)
- Pipeline order: Classify -> Filter ghosts -> Detect disfluencies -> Align
- _disfluency field persisted in saved assessments
- Console logs confirm disfluency processing
</success_criteria>

<output>
After completion, create `.planning/phases/14-disfluency-detection/14-03-SUMMARY.md`
</output>
