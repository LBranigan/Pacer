---
phase: 08-student-experience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/gamification.js
  - js/sprite-animator.js
autonomous: true

must_haves:
  truths:
    - "Scoring logic computes points, streaks, and level from alignment data"
    - "Sprite animator renders frames from a sprite sheet on canvas"
  artifacts:
    - path: "js/gamification.js"
      provides: "Pure scoring logic"
      exports: ["computeScore"]
    - path: "js/sprite-animator.js"
      provides: "Canvas sprite sheet renderer"
      exports: ["SpriteAnimator"]
  key_links:
    - from: "js/gamification.js"
      to: "alignment array"
      via: "computeScore(alignment, pastScores)"
      pattern: "export function computeScore"
---

<objective>
Create the pure logic modules for gamification scoring and canvas sprite animation.

Purpose: These are dependency-free modules that Plan 02 and 03 will consume. Keeping them separate ensures testability and clean architecture.
Output: js/gamification.js and js/sprite-animator.js
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-student-experience/08-RESEARCH.md
@js/audio-playback.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gamification scoring module</name>
  <files>js/gamification.js</files>
  <action>
Create js/gamification.js as a pure ES module with a single export: computeScore(alignment, pastScores).

Input:
- alignment: array of {type: 'correct'|'substitution'|'omission'|'insertion', ref, hyp} (same format used throughout the app)
- pastScores: array of previous total scores (numbers) for progress calculation, may be empty

Logic:
- Points: +10 per correct word, +0 for substitution/omission, insertions ignored (matches existing ORF standard where insertions don't count)
- Streak: count consecutive correct words. Track currentStreak and bestStreak. Streak breaks on substitution or omission.
- Bonus: if bestStreak >= 5, add bestStreak * 2 bonus points
- Level: floor(totalPoints / 100) + 1, capped at 10
- Progress: if pastScores has entries, compute improvement ratio = totalPoints / average(pastScores). Clamp between 0 and 2. If no past scores, progress = null.

Return object: { totalPoints, bestStreak, currentStreak, level, bonus, progress, wordsCorrect, wordsTotal }

Where wordsTotal = alignment.filter(a => a.type !== 'insertion').length (reference words only, matching ORF convention).

Keep module pure -- no DOM, no storage, no imports.
  </action>
  <verify>
Open browser console on index.html, run:
import('./js/gamification.js').then(m => console.log(m.computeScore([{type:'correct',ref:'the'},{type:'correct',ref:'cat'},{type:'substitution',ref:'sat',hyp:'set'},{type:'correct',ref:'down'}], [])))
Should return: { totalPoints: 30, bestStreak: 2, currentStreak: 1, level: 1, bonus: 0, progress: null, wordsCorrect: 3, wordsTotal: 4 }
  </verify>
  <done>computeScore returns correct points, streaks, level, bonus, and progress for any alignment array</done>
</task>

<task type="auto">
  <name>Task 2: Sprite animator class</name>
  <files>js/sprite-animator.js</files>
  <action>
Create js/sprite-animator.js exporting a SpriteAnimator class for rendering animated characters on a Canvas 2D context.

Since we don't have actual sprite sheet art yet, this class works with geometric placeholder characters (as noted in research: "start with geometric placeholder").

Constructor: SpriteAnimator(ctx, options)
- ctx: CanvasRenderingContext2D
- options: { size: 32, color: '#4CAF50', battleColor: '#F44336' }

Methods:

1. drawIdle(x, y) - Draw the character at position (x, y) in idle state.
   Character: colored circle (options.color) with simple face (two dot eyes, smile arc).
   Size determined by options.size.

2. drawHop(x, y, hopPhase) - Draw character mid-hop. hopPhase is 0-1 float.
   Apply a parabolic y-offset: yOffset = -sin(hopPhase * PI) * size * 0.8
   Draw same character at (x, y + yOffset) with slight squash at landing (hopPhase > 0.9).

3. drawBattle(x, y, battlePhase) - Draw character battling an obstacle at error word.
   battlePhase is 0-1 float.
   Character shakes (small random x offset), color transitions toward battleColor.
   Draw a simple red obstacle (spiky circle) at (x + size * 1.2, y) that shrinks as battlePhase increases (character overcoming it).

4. drawEnemy(x, y, scale) - Draw the obstacle/enemy independently.
   Red spiky circle (8 points). Scale 0-1 controls size.

All drawing uses ctx arc, lineTo, fill, stroke -- no external images needed.

No imports, no DOM manipulation. Pure canvas drawing utility.
  </action>
  <verify>
Create a quick test: add a temporary canvas to index.html, import SpriteAnimator, instantiate with canvas.getContext('2d'), call drawIdle(50,50), drawHop(150,50,0.5), drawBattle(250,50,0.5). Verify three characters render visually. Remove test after confirming.
  </verify>
  <done>SpriteAnimator renders idle, hopping, and battling character states on any Canvas 2D context</done>
</task>

</tasks>

<verification>
- Both modules import cleanly as ES modules (no syntax errors)
- gamification.js has zero dependencies
- sprite-animator.js has zero dependencies
- computeScore handles edge cases: empty alignment, all correct, all errors
</verification>

<success_criteria>
- js/gamification.js exports computeScore with correct scoring logic
- js/sprite-animator.js exports SpriteAnimator with idle/hop/battle drawing
- Both are pure modules with no side effects
</success_criteria>

<output>
After completion, create `.planning/phases/08-student-experience/08-01-SUMMARY.md`
</output>
