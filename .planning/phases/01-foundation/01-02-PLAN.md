---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - manifest.json
  - sw.js
  - icons/icon-192.png
  - icons/icon-512.png
  - index.html
autonomous: true

must_haves:
  truths:
    - "App is installable as PWA on Chrome/Edge (install prompt appears)"
    - "App shell loads from cache when offline (after first visit)"
    - "STT API calls still go to network (not cached)"
  artifacts:
    - path: "manifest.json"
      provides: "PWA metadata"
      contains: "display.*standalone"
    - path: "sw.js"
      provides: "Service worker with cache-first for shell, network passthrough for API"
      contains: "CACHE_NAME"
    - path: "icons/icon-192.png"
      provides: "PWA icon 192x192"
    - path: "icons/icon-512.png"
      provides: "PWA icon 512x512"
  key_links:
    - from: "index.html"
      to: "manifest.json"
      via: "link rel=manifest"
      pattern: "rel=\"manifest\""
    - from: "js/app.js"
      to: "sw.js"
      via: "serviceWorker.register"
      pattern: "serviceWorker\\.register"
    - from: "sw.js"
      to: "index.html, style.css, js/*.js"
      via: "cache.addAll in install event"
      pattern: "addAll"
---

<objective>
Add PWA support: manifest.json, service worker, and placeholder icons.

Purpose: Makes the app installable on classroom devices (Chromebooks, tablets) and enables offline loading of the app shell. STT API calls still require network.

Output: manifest.json, sw.js, icons/, and updates to index.html (manifest link) and js/app.js (SW registration).
</objective>

<execution_context>
@/home/brani/.claude/get-shit-done/workflows/execute-plan.md
@/home/brani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@index.html
@js/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PWA assets</name>
  <files>manifest.json, sw.js, icons/icon-192.png, icons/icon-512.png</files>
  <action>
1. Create `manifest.json` at project root:
```json
{
  "name": "Oral Reading Fluency Assessment",
  "short_name": "ORF Assess",
  "start_url": "./index.html",
  "display": "standalone",
  "background_color": "#f5f5f5",
  "theme_color": "#d32f2f",
  "icons": [
    { "src": "icons/icon-192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "icons/icon-512.png", "sizes": "512x512", "type": "image/png" }
  ]
}
```

2. Create `sw.js` at project root with:
   - `CACHE_NAME = 'orf-v1'`
   - `SHELL` array listing: `'./', './index.html', './style.css', './js/app.js', './js/ui.js', './js/recorder.js', './js/file-handler.js', './js/stt-api.js', './manifest.json'`
   - `install` event: `caches.open(CACHE_NAME).then(c => c.addAll(SHELL))`
   - `fetch` event: If request URL includes `googleapis.com`, return (let it go to network). Otherwise, respond with cache match falling back to network fetch.
   - `activate` event: Delete old caches where key !== CACHE_NAME.

3. Create `icons/` directory with placeholder PNG icons:
   - Generate simple colored-square placeholder PNGs using a canvas approach or write minimal valid PNG binary data. The simplest approach: use Node.js to create them if available, or create minimal 1x1 PNGs that browsers will accept. A pragmatic approach is to use `npx create-pwa-icons` or simply create placeholder files that are valid PNGs.
   - Simplest: use a bash one-liner with `convert` (ImageMagick) if available, or write a tiny Node script to create colored rectangles, or just create minimal valid PNG files. The key requirement is that they are valid PNG files at the stated dimensions.
   - If no image tools available, create a small Node.js script (`scripts/gen-icons.js`) that uses Canvas API or writes raw PNG bytes, run it, then delete the script. Or use `npx pwa-asset-generator` if it works simply.
   - FALLBACK: If generating real PNGs is too complex, create minimal valid PNG placeholder files. The app will still be installable; icons just won't look polished.
  </action>
  <verify>
```bash
cat manifest.json | grep "standalone"
cat sw.js | grep "CACHE_NAME"
ls icons/
file icons/icon-192.png  # Should say PNG image data
```
  </verify>
  <done>manifest.json, sw.js, and two valid PNG icon files exist at correct paths.</done>
</task>

<task type="auto">
  <name>Task 2: Wire PWA into existing app</name>
  <files>index.html, js/app.js</files>
  <action>
1. In `index.html` `<head>`, add (if not already present from Plan 01):
   - `<link rel="manifest" href="manifest.json">`
   - `<link rel="apple-touch-icon" href="icons/icon-192.png">`
   - Confirm `<meta name="theme-color" content="#d32f2f">` exists (added in Plan 01)

2. In `js/app.js`, add service worker registration at the top level (before or after init calls):
```javascript
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js')
    .then(reg => console.log('SW registered:', reg.scope))
    .catch(err => console.warn('SW registration failed:', err));
}
```
  </action>
  <verify>
```bash
grep 'rel="manifest"' index.html
grep 'serviceWorker.register' js/app.js
```
Start server with `npx serve .` and open in Chrome. Check:
- DevTools > Application > Manifest shows app info
- DevTools > Application > Service Workers shows sw.js registered
- DevTools > Application > Cache Storage shows 'orf-v1' with cached files
  </verify>
  <done>index.html links to manifest. App.js registers service worker. PWA install prompt available in Chrome/Edge. App shell cacheable for offline use.</done>
</task>

</tasks>

<verification>
1. `manifest.json` is valid JSON with name, icons, display: standalone
2. `sw.js` caches app shell files and passes through API calls
3. Icon files exist and are valid PNGs
4. `index.html` has `<link rel="manifest">`
5. `js/app.js` registers service worker
6. Chrome DevTools shows manifest parsed, SW active, cache populated
7. Lighthouse PWA audit passes installability checks (or at minimum: manifest + SW + icons present)
</verification>

<success_criteria>
- App is installable as PWA (INFR-05)
- App shell loads from cache after first visit
- STT API calls are not cached (go to network)
- All functionality from Plan 01 still works after PWA additions
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
